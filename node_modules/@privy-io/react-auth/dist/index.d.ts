import react, { ReactElement } from 'react';
import { ExternalProvider, StaticJsonRpcProvider, Web3Provider, TransactionResponse } from '@ethersproject/providers';
import { CountryCode } from 'libphonenumber-js/min';
import { AbstractProvider } from 'web3-core';
import EventEmitter from 'eventemitter3';
import { PasskeyAuthenticateInputType } from '@privy-io/public-api';
import { TypedMessage as TypedMessage$1, MessageTypes as MessageTypes$1 } from '@metamask/eth-sig-util';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { TurnstileProps } from '@marsidev/react-turnstile';
import { Store, EIP6963ProviderDetail } from 'mipd';
import * as _simplewebauthn_types from '@simplewebauthn/types';
import { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/types';
import { FetchOptions } from 'ofetch';

/**
 * We support a subset of the provider methods found here:
 *
 *     https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods
 *
 * For now, we're focused on signing-related methods because the iframe (this code)
 * is the only place that has access to the private key and thus is the only one
 * who can create signatures. All other methods do not need the private key and
 * can therefore be implemented by clients of the iframe.
 */

declare const SUPPORTED_JSON_RPC_METHODS: readonly ["eth_sign", "eth_populateTransactionRequest", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4"];
type JsonRpcMethodType = (typeof SUPPORTED_JSON_RPC_METHODS)[number];
type Quantity = string | number | bigint;
type UnsignedTransactionRequest = {
    from?: string;
    to?: string;
    nonce?: Quantity;
    gasLimit?: Quantity;
    gasPrice?: Quantity;
    data?: ArrayLike<number> | string;
    value?: Quantity;
    chainId?: number;
    type?: number;
    accessList?: Array<{
        address: string;
        storageKeys: Array<string>;
    }> | Array<[string, Array<string>]> | Record<string, Array<string>>;
    maxPriorityFeePerGas?: Quantity;
    maxFeePerGas?: Quantity;
};
type TransactionLog = {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
};
type TransactionReceipt = {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    logs: Array<TransactionLog>;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    blockNumber: number;
    confirmations: number;
    byzantium: boolean;
    type: number;
    status?: number;
    gasUsed: string;
    cumulativeGasUsed: string;
    effectiveGasPrice?: string;
};
interface BaseRpcRequestType {
    method: JsonRpcMethodType;
}
interface eth_populateTransactionRequest extends BaseRpcRequestType {
    method: 'eth_populateTransactionRequest';
    params: [UnsignedTransactionRequest];
}
interface eth_populateTransactionRequestResponse {
    method: 'eth_populateTransactionRequest';
    data: UnsignedTransactionRequest;
}
interface eth_signTransaction extends BaseRpcRequestType {
    method: 'eth_signTransaction';
    params: [UnsignedTransactionRequest];
}
interface eth_sign extends BaseRpcRequestType {
    method: 'eth_sign';
    params: [address: string, message: string];
}
interface eth_signResponse {
    method: 'eth_sign';
    data: string;
}
interface personal_sign extends BaseRpcRequestType {
    method: 'personal_sign';
    params: [string, string];
}
interface personal_signResponse {
    method: 'personal_sign';
    data: string;
}
interface eth_signTransactionResponse {
    method: 'eth_signTransaction';
    data: string;
}
interface eth_signTypedData_v4 extends BaseRpcRequestType {
    method: 'eth_signTypedData_v4';
    params: [string, TypedMessage$1<MessageTypes$1> | string];
}
interface eth_signTypedData_v4Response {
    method: 'eth_signTypedData_v4';
    data: string;
}
type RpcRequestType = eth_signTransaction | eth_populateTransactionRequest | eth_sign | personal_sign | eth_signTypedData_v4;
type RpcResponseType = eth_signTransactionResponse | eth_populateTransactionRequestResponse | eth_signResponse | personal_signResponse | eth_signTypedData_v4Response;

/**
 * These types are fully compatible with WAGMI chain types, in case
 * we need interop in the future.
 */
type RpcUrls = {
    http: readonly string[];
    webSocket?: readonly string[];
};
type NativeCurrency = {
    name: string;
    /** 2-6 characters long */
    symbol: string;
    decimals: number;
};
type BlockExplorer = {
    name: string;
    url: string;
};
/** A subset of WAGMI's chain type
 * https://github.com/wagmi-dev/references/blob/6aea7ee9c65cfac24f33173ab3c98176b8366f05/packages/chains/src/types.ts#L8
 *
 * @example
 *
 * override the RPC URL for a chain
 *
 * ```ts
 * import { mainnet } from 'viem/chains';
 *
 * const mainnetOverride: Chain = {
 *  ...mainnet,
 *  rpcUrls: {
 *    ...mainnet.rpcUrls,
 *    privyWalletOverride: {
 *      http: [INSERT_MAINNET_OVERRIDE_URL],
 *    },
 *  },
 * };
 *
 * ```
 * or
 * ```ts
 * import { mainnet } from 'viem/chains';
 * import { addRpcUrlOverrideToChain } from '@privy-io/react-auth';
 *
 * const mainnetOverride = addRpcUrlOverrideToChain(mainnet, INSERT_MAINNET_OVERRIDE_URL);
 * ```
 *
 */
type Chain = {
    /** Id in number form */
    id: number;
    /** Human readable name */
    name: string;
    /** Internal network name */
    network?: string;
    /** Currency used by chain */
    nativeCurrency: NativeCurrency;
    /** Collection of block explorers */
    blockExplorers?: {
        [key: string]: BlockExplorer;
        default: BlockExplorer;
    };
    /** Collection of RPC endpoints */
    rpcUrls: {
        [key: string]: RpcUrls;
        default: RpcUrls;
    } | {
        [key: string]: RpcUrls;
        default: RpcUrls;
        /** @optional Allows you to override the RPC url for this chain */
        privyWalletOverride: RpcUrls;
    };
    /** Flag for test networks */
    testnet?: boolean;
};
/**
 * RPC configuration for wallets.
 */
type RpcConfig = {
    /**
     * Mapping of chainId to RPC URL. Overrides Privy default RPC URLs that are shared across projects. Set your own RPC URLs
     * to avoid rate limits or other throughput bottlenecks.
     *
     * Do not provide an RPC URL that can serve multiple networks. You should only provide RPC URLs that are speciifc to the
     * chain ID you'd like to override.
     */
    rpcUrls?: {
        [key: number]: string;
    };
    /**
     * Mapping between `walletClientType`s to the length of time after which RPC requests will timeout for that
     * `walletClientType`.
     *
     * By default, all RPC requests through Privy will timeout after 2 mins (120000 ms). Use this object to
     * override the RPC timeout in ms for specific` walletClientType`s, e.g. 'safe', in order to extend or
     * shorten the timeout duration.
     */
    rpcTimeouts?: {
        [key in WalletClientType]?: number;
    };
};

declare const DEFAULT_SUPPORTED_CHAINS: readonly [Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain, Chain];

type WalletCreateRequestDataType = {
    accessToken: string;
    recoveryPassword?: string;
    recoveryMethod?: 'user-passcode' | 'google-drive';
    recoveryAccessToken?: string;
    /**
     * Will be deprecated in a future release, use `recoveryPassword` instead
     * @deprecated
     */
    recoveryPin?: string;
};
type WalletSetRecoveryPasswordRequestDataType = {
    accessToken: string;
    address: string;
    recoveryPassword: string;
    /**
     * Will be deprecated in a future release, use `recoveryPassword` instead
     * @deprecated
     */
    recoveryPin?: string;
};
type WalletRecoverRequestDataType = {
    address: string;
    accessToken: string;
    mfaCode?: string | PasskeyAuthenticateInputType['authenticator_response'];
    mfaMethod?: MfaMethod;
    relyingParty?: string;
    recoveryPassword?: string;
    recoveryMethod?: 'user-passcode' | 'google-drive';
    recoveryAccessToken?: string;
    /**
     * Will be deprecated in a future release, use `recoveryPassword` instead
     * @deprecated
     */
    recoveryPin?: string;
};
type WalletConnectRequestDataType = {
    accessToken: string;
    address: string;
};
type WalletRpcRequestDataType = {
    accessToken: string;
    mfaCode?: string | PasskeyAuthenticateInputType['authenticator_response'];
    mfaMethod?: MfaMethod;
    relyingParty?: string;
    address: string;
    request: RpcRequestType;
};
type MfaVerifyRequestDataType = {
    accessToken: string;
};
type MfaInitEnrollmentRequestDataType = {
    accessToken: string;
    method: 'sms';
    phoneNumber: string;
} | {
    accessToken: string;
    method: 'totp';
};
type MfaSubmitEnrollmentRequestDataType = {
    accessToken: string;
    method: 'sms';
    code: string;
    phoneNumber: string;
} | {
    accessToken: string;
    method: 'totp';
    code: string;
} | {
    accessToken: string;
    method: 'passkey';
    credentialIds: string[];
};
type MfaUnenrollRequestDataType = {
    accessToken: string;
    method: 'sms' | 'totp';
};
type MfaClearRequestDataType = {
    userId: string;
};
type FarcasterSignerInitRequestDataType = {
    address: string;
    hdWalletIndex: number | null;
    accessToken: string;
    mfaCode: string | PasskeyAuthenticateInputType['authenticator_response'] | null;
    mfaMethod: string | null;
    relyingParty: string;
};
type FarcasterSignRequestDataType = {
    address: string;
    hdWalletIndex: number | null;
    accessToken: string;
    mfaCode: string | PasskeyAuthenticateInputType['authenticator_response'] | null;
    mfaMethod: string | null;
    relyingParty: string;
    payload: {
        hash: string;
    };
    fid: bigint;
};
type WalletCreateResponseDataType = {
    address: string;
};
type WalletConnectResponseDataType = {
    address: string;
};
type WalletRecoverResponseDataType = {
    address: string;
};
type WalletSetRecoveryPasswordResponseDataType = {
    address: string;
};
type WalletRpcResponseDataType = {
    address: string;
    response: RpcResponseType;
};
type MfaVerifyResponseDataType = Record<string, never>;
type MfaInitEnrollmentResponseDataType = {
    method: string;
    secret?: string;
    authUrl?: string;
};
type MfaSubmitEnrollmentResponseDataType = Record<string, never>;
type MfaUnenrollResponseDataType = Record<string, never>;
type MfaClearResponseDataType = Record<string, never>;
type FarcasterSignerInitResponseDataType = PrivyFarcasterSignerInitResponse;
type FarcasterSignResponseDataType = {
    hash: string;
    signature: string;
};
declare const PrivyIframeErrorTypes: readonly ["error", "invalid_request_arguments", "wallet_not_on_device", "invalid_recovery_pin", "insufficient_funds", "missing_or_invalid_mfa", "mfa_verification_max_attempts_reached", "mfa_timeout", "twilio_verification_failed"];
type PrivyIframeErrorTypesType = (typeof PrivyIframeErrorTypes)[number];
interface EmbeddedWalletProxy {
    create: (data: WalletCreateRequestDataType) => Promise<WalletCreateResponseDataType>;
    connect: (data: WalletConnectRequestDataType) => Promise<WalletConnectResponseDataType>;
    recover: (data: WalletRecoverRequestDataType) => Promise<WalletRecoverResponseDataType>;
    setRecoveryPassword: (data: WalletSetRecoveryPasswordRequestDataType) => Promise<WalletSetRecoveryPasswordResponseDataType>;
    rpc: (data: WalletRpcRequestDataType) => Promise<WalletRpcResponseDataType>;
    verifyMfa: (data: MfaVerifyRequestDataType) => Promise<MfaVerifyResponseDataType>;
    initEnrollMfa: (data: MfaInitEnrollmentRequestDataType) => Promise<MfaInitEnrollmentResponseDataType>;
    submitEnrollMfa: (data: MfaSubmitEnrollmentRequestDataType) => Promise<MfaSubmitEnrollmentResponseDataType>;
    unenrollMfa: (data: MfaUnenrollRequestDataType) => Promise<MfaUnenrollResponseDataType>;
    clearMfa: (data: MfaClearRequestDataType) => Promise<MfaClearResponseDataType>;
    initFarcasterSigner: (data: FarcasterSignerInitRequestDataType) => Promise<FarcasterSignerInitResponseDataType>;
    signFarcasterMessage: (data: FarcasterSignRequestDataType) => Promise<FarcasterSignResponseDataType>;
}

declare abstract class PrivyError extends Error {
    /**
     * Privy error type.
     */
    abstract type: string;
    /**
     * Original Error object, it the error originated client-side.
     */
    cause?: Error;
    /**
     * An optional error code, often included in Privy API responses.
     */
    privyErrorCode?: PrivyErrorCode;
    /**
     * @param type Privy error type.
     * @param message Human-readable message.
     * @param cause Source of this error.
     */
    protected constructor(message: string, cause?: unknown, privyErrorCode?: PrivyErrorCode);
    toString(): string;
}
/**
 * The PrivyConnector instance threw an exception.
 */
declare class PrivyConnectorError extends PrivyError {
    type: string;
    constructor(message: string, cause?: unknown, privyErrorCode?: PrivyErrorCode);
}
declare enum PrivyErrorCode {
    OAUTH_ACCOUNT_SUSPENDED = "oauth_account_suspended",
    MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id",
    MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id",
    MISSING_OR_INVALID_TOKEN = "missing_or_invalid_token",
    INVALID_DATA = "invalid_data",
    INVALID_CAPTCHA = "invalid_captcha",
    LINKED_TO_ANOTHER_USER = "linked_to_another_user",
    CANNOT_LINK_MORE_OF_TYPE = "cannot_link_more_of_type",
    FAILED_TO_LINK_ACCOUNT = "failed_to_link_account",
    ALLOWLIST_REJECTED = "allowlist_rejected",
    OAUTH_USER_DENIED = "oauth_user_denied",
    UNKNOWN_AUTH_ERROR = "unknown_auth_error",
    USER_EXITED_AUTH_FLOW = "exited_auth_flow",
    USER_EXITED_LINK_FLOW = "exited_link_flow",
    USER_EXITED_SET_PASSWORD_FLOW = "user_exited_set_password_flow",
    MUST_BE_AUTHENTICATED = "must_be_authenticated",
    UNKNOWN_CONNECT_WALLET_ERROR = "unknown_connect_wallet_error",
    GENERIC_CONNECT_WALLET_ERROR = "generic_connect_wallet_error",
    CLIENT_REQUEST_TIMEOUT = "client_request_timeout",
    INVALID_CREDENTIALS = "invalid_credentials",
    MISSING_MFA_CREDENTIALS = "missing_or_invalid_mfa",
    UNKNOWN_MFA_ERROR = "unknown_mfa_error",
    EMBEDDED_WALLET_ALREADY_EXISTS = "embedded_wallet_already_exists",
    EMBEDDED_WALLET_NOT_FOUND = "embedded_wallet_not_found",
    UNKNOWN_EMBEDDED_WALLET_ERROR = "unknown_embedded_wallet_error",
    EMBEDDED_WALLET_PASSWORD_UNCONFIRMED = "embedded_wallet_password_unconfirmed",
    EMBEDDED_WALLET_PASSWORD_ALREADY_EXISTS = "embedded_wallet_password_already_exists",
    EMBEDDED_WALLET_RECOVERY_ALREADY_EXISTS = "embedded_wallet_recovery_already_exists",
    TRANSACTION_FAILURE = "transaction_failure",
    UNSUPPORTED_CHAIN_ID = "unsupported_chain_id",
    CAPTCHA_TIMEOUT = "captcha_timeout",
    INVALID_MESSAGE = "invalid_message",
    UNABLE_TO_SIGN = "unable_to_sign",
    CAPTCHA_FAILURE = "captcha_failure",
    CAPTCHA_DISABLED = "captcha_disabled",
    SESSION_STORAGE_UNAVAILABLE = "session_storage_unavailable",
    TOO_MANY_REQUESTS = "too_many_requests",
    USER_LIMIT_REACHED = "max_accounts_reached",
    DISALLOWED_LOGIN_METHOD = "disallowed_login_method",
    PASSKEY_NOT_ALLOWED = "passkey_not_allowed"
}

declare class WalletTimeoutError extends PrivyConnectorError {
    type: string;
    constructor();
}
/**
 * A ProviderRpcError combines the necessary bits of the {PrivyError} with the
 * EIP-compliant ProviderRpcError. This is meant to be a type around errors raised
 * by the ethereum provider.
 */
declare class ProviderRpcError extends PrivyError {
    type: string;
    readonly code: number;
    readonly data?: unknown;
    constructor(message: string, code: number, data?: unknown);
}

declare global {
    interface Window {
        ethereum?: any;
    }
}
type ProviderConnectInfo = {
    chainId: string;
};
type OnConnectEventHandler = (connectInfo: ProviderConnectInfo) => void;
type OnDisconnectEventHandler = (error: ProviderRpcError) => void;
type OnChainChangedEventHandler = (chainId: string | number) => void;
type OnAccountsChangedEventHandler = (accounts: string[]) => void;
type ProviderMessage = {
    type: string;
    data: unknown;
};
type OnMessageEventHandler = (message: ProviderMessage) => void;
type EIP1193OnEventHandler = OnConnectEventHandler | OnDisconnectEventHandler | OnChainChangedEventHandler | OnAccountsChangedEventHandler | OnMessageEventHandler;
interface EIP1193Provider {
    rpcTimeoutDuration?: number;
    request: (request: {
        method: string;
        params?: Array<any> | undefined;
    }) => Promise<any>;
    on: (eventName: string, listener: EIP1193OnEventHandler) => any;
    removeListener: (eventName: string | symbol, listener: (...args: any[]) => void) => any;
}
/**
 * @hidden
 *
 * The PrivyProxyProvider adds a middleware layer on top of the underlying wallet provider.
 * */
declare class PrivyProxyProvider implements EIP1193Provider {
    rpcTimeoutDuration: number;
    walletProvider?: EIP1193Provider;
    private _subscriptions;
    constructor(walletProvider?: EIP1193Provider, rpcTimeoutDuration?: number);
    on(eventName: string, listener: (...args: any[]) => void): any;
    request(request: {
        method: string;
        params?: any[] | undefined;
    }): Promise<any>;
    removeListener: (eventName: string | symbol, listener: (...args: any[]) => void) => any;
    walletTimeout: (error?: WalletTimeoutError, timeoutMs?: number) => Promise<string[]>;
    setWalletProvider: (provider: EIP1193Provider) => void;
}
interface RequestArguments {
    readonly method: string;
    readonly params?: readonly unknown[] | object;
}
declare class Embedded1193Provider extends EventEmitter implements EIP1193Provider {
    walletProxy: EmbeddedWalletProxy;
    address: string;
    provider: StaticJsonRpcProvider;
    chainId: number;
    rpcConfig: RpcConfig;
    chains: Chain[];
    rpcTimeoutDuration: number;
    appId: string;
    constructor(walletProxy: EmbeddedWalletProxy, address: string, rpcConfig: RpcConfig, chains: Chain[], appId: string, chainId?: number);
    handleSendTransaction(args: RequestArguments): Promise<string>;
    private handleSwitchEthereumChain;
    private handlePersonalSign;
    private handleSignedTypedData;
    private handleEstimateGas;
    request(args: RequestArguments): Promise<unknown>;
    connect(): Promise<string | null>;
}
/**
 * @hidden
 *
 * Shim to convert to ethers-compatible ExternalProvider class.
 */
declare class AsExternalProvider extends PrivyProxyProvider implements ExternalProvider {
    constructor(provider: EIP1193Provider);
    isMetaMask?: boolean;
    isStatus?: boolean;
    host?: string;
    path?: string;
    sendAsync?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    send?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
}

interface ConnectorEvents {
    walletsUpdated(): void;
    initialized(): void;
}
/**
 * @hidden
 *
 * A WalletConnector is identified by a connectorType and walletClientType. A
 * connectorType includes injected, wallet_connect, etc. A walletClientType
 * includes metamask, trustwallet, etc.
 *
 * Each WalletConnector manages a list of wallets, identified by an address
 * and chainId. Each wallet has a connected property indicating its current
 * connection status, which is determined based on events emitted by the
 * underlying provider.
 *
 * The WalletConnector also emits two events: walletsUpdated and initialized.
 * The walletsUpdated event is triggered when the list of wallets changes,
 * while the initialized event is triggered when the WalletConnector is
 * ready and has successfully executed the syncAccounts() function for
 * the first time.
 */
declare abstract class WalletConnector extends EventEmitter<ConnectorEvents> {
    connected: boolean;
    initialized: boolean;
    wallets: BaseConnectedWallet[];
    walletClientType: WalletClientType;
    chains: Chain[];
    defaultChain: Chain;
    rpcConfig: RpcConfig;
    rpcTimeoutDuration: number;
    abstract connectorType: ConnectorType;
    abstract proxyProvider: PrivyProxyProvider | Embedded1193Provider;
    constructor(walletClientType: WalletClientType, chains: Chain[], defaultChain: Chain, rpcConfig: RpcConfig);
    /**
     * Builds a connected wallet object to be exposed to the developer. This object
     * contains the address, chainId, and a few helper methods.
     *
     * Provider methods share the PrivyProxyProvider instance. This means that multiple
     * wallets may share the same provider if one wallet was disconnected and another
     * wallet was connected.
     *
     * A wallet is considered connected if it is present in the wallets array and is
     * in a connected state.
     */
    buildConnectedWallet(address: string, chainId: string, meta: ConnectedWalletMetadata): BaseConnectedWallet;
    /**
     * Sync all accounts available via the provider if the wallet is connected.
     *
     * @param prefetchedAccounts - pass in an accounts array from eth_accounts if already fetched to avoid a repeated call
     */
    syncAccounts(prefetchedAccounts?: string[]): Promise<void>;
    /**
     * Get the most recently connected wallet.
     */
    getConnectedWallet(): Promise<BaseConnectedWallet | null>;
    /**
     * As a proxy for "connected", we call eth_accounts and consider the client
     * connected if at least one account is returned.
     */
    isConnected(): Promise<boolean>;
    /**
     * Perform personal_sign with the user's wallet.
     *
     * @param {string} message The message to sign.
     * @returns {string} The resulting signature.
     */
    sign(message: string): Promise<string>;
    protected onAccountsChanged: (accounts: string[]) => void;
    protected onChainChanged: (chainId: string) => void;
    protected onDisconnect: () => void;
    protected onConnect: () => void;
    subscribeListeners(): void;
    unsubscribeListeners(): void;
    abstract get walletBranding(): WalletBranding;
    abstract initialize(): Promise<void>;
    abstract connect(options: {
        showPrompt?: boolean;
        chainId?: number;
    }): Promise<BaseConnectedWallet | null>;
    abstract disconnect(): void;
    abstract promptConnection(walletClientType: WalletClientType): void;
}

interface ResponseEmailAccount {
    type: 'email';
    address: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponsePhoneAccount {
    type: 'phone';
    phoneNumber: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseEthereumAccount {
    type: 'wallet';
    address: string;
    /**
     * @deprecated This will be removed in favor of the CAIP-2 formatted chain_id field.
     *
     * Chain type of the wallet address.
     */
    chain_type: 'ethereum';
    chain_id?: string;
    /**
     * @deprecated Use `wallet_client_type` instead.
     */
    wallet_client: 'privy' | 'unknown';
    wallet_client_type?: string;
    connector_type?: string;
    recovery_method?: 'privy' | 'user-passcode';
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseFarcasterAccount {
    type: 'farcaster';
    fid: number;
    owner_address: string;
    username: string | null;
    display_name: string | null;
    bio: string | null;
    profile_picture_url: string | null;
    homepage_url: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
    signer_public_key: string | null;
}
interface ResponseOAuthGoogle {
    type: 'google_oauth';
    subject: string;
    email: string;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthTwitter {
    type: 'twitter_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    profile_picture_url: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthDiscord {
    type: 'discord_oauth';
    subject: string;
    username: string | null;
    email: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthGithub {
    type: 'github_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    email: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthSpotify {
    type: 'spotify_oauth';
    subject: string;
    email: string | null;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthInstagram {
    type: 'instagram_oauth';
    subject: string;
    username: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthTiktok {
    type: 'tiktok_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthLinkedIn {
    type: 'linkedin_oauth';
    subject: string;
    name: string | null;
    email: string | null;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseOAuthApple {
    type: 'apple_oauth';
    subject: string;
    email: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseCustomJwtAccount {
    type: 'custom_auth';
    custom_user_id: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponsePasskeyAccount {
    type: 'passkey';
    credential_id: string;
    enrolled_in_mfa: boolean;
    authenticator_name?: string;
    created_with_device?: string;
    created_with_os?: string;
    created_with_browser?: string;
    verified_at: number;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
interface ResponseTelegramAccount {
    type: 'telegram';
    telegramUserId: string;
    firstName: string;
    username: string | null;
    first_verified_at: number | null;
    latest_verified_at: number | null;
}
type LinkedAccountsResponseType = Array<ResponseEmailAccount | ResponsePhoneAccount | ResponseEthereumAccount | ResponseOAuthGoogle | ResponseOAuthTwitter | ResponseOAuthDiscord | ResponseOAuthGithub | ResponseOAuthSpotify | ResponseOAuthInstagram | ResponseOAuthTiktok | ResponseOAuthLinkedIn | ResponseOAuthApple | ResponseCustomJwtAccount | ResponseFarcasterAccount | ResponsePasskeyAccount | ResponseTelegramAccount>;
interface ResponseSmsMfaMethod {
    type: 'sms';
    verified_at: number;
}
type LinkedMfaMethodsResponseType = Array<ResponseSmsMfaMethod>;
interface GetCurrentUserResponse {
    id: string;
    created_at: number;
    linked_accounts: LinkedAccountsResponseType;
    mfa_methods: LinkedMfaMethodsResponseType;
    has_accepted_terms: boolean;
}

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
/**
 * A raw http handler for making requests to the Privy API. It requires a Session
 * object, which is used for fetching and including any tokens that are required
 * for requests.
 *
 * Should not be used for external requests, as we attach a good deal of metadata to requests.
 */
declare class Http {
    fallbackApiUrl: string;
    private appId;
    private client;
    private defaults;
    private sdkVersion;
    private baseFetch;
    private clientAnalyticsId;
    constructor(appId: string, client: PrivyClient, defaults: DefaultsType);
    get<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
    post<T = any, D = any>(path: string, data?: D, config?: FetchOptions<'json'>): Promise<T>;
    delete<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
}

/**
 * Valid /session and <>/authenticate calls will respond with a token
 * as well as a valid user object for streamlining.
 */
interface ValidSessionResponse {
    user: GetCurrentUserResponse;
    token: string;
    refresh_token: string | null;
    is_new_user?: boolean;
    session_update_action?: 'set' | 'ignore' | 'clear';
    oauth_provider_tokens?: {
        provider: string;
        access_token: string;
        access_token_expires_in_seconds?: number;
        refresh_token?: string;
        scopes?: string[];
    };
}

type AuthMeta = {
    [key: string]: any;
};
/**
 * An auth flow is an encapsulation of the business logic required for a given
 * authentication process. It requires at least one definitive `authenticate`
 * method that does the final token handshaking with the API, but may also
 * include any number of methods/API calls necessary to set up the state (e.g.
 * sending an email before being able to do a passwordless code login)
 */
interface AuthFlow {
    api?: Http;
    /**
     * Any meta information necessary for the auth flow, that may also need to be
     * shared out to things like frontend components for displaying state of the
     * auth flow
     */
    meta: AuthMeta;
    /**
     * Handles the API authentication call(s) to log users in.
     * Any preconditions must be addressed prior to calling
     */
    authenticate(): Promise<ValidSessionResponse>;
    /**
     * Handles the API link call(s) to link new user accounts.
     * Requires user to already be logged in when called.
     * Any preconditions must be addressed prior to calling
     */
    link(): Promise<GetCurrentUserResponse>;
}

interface ConnectorManagerEvents {
    walletsUpdated(): void;
    connectorInitialized(): void;
}
declare class ConnectorManager extends EventEmitter<ConnectorManagerEvents> {
    walletConnectors: WalletConnector[];
    initialized: boolean;
    private storedConnections;
    private activeWallet?;
    private privyAppId;
    private walletConnectCloudProjectId;
    private rpcConfig;
    private chains;
    private defaultChain;
    private store;
    private walletList;
    private shouldEnforceDefaultChainOnConnect;
    private privyAppName;
    constructor(privyAppId: string, walletConnectCloudProjectId: string, rpcConfig: RpcConfig, chains: Chain[], defaultChain: Chain, store: Store, walletList: WalletListEntry[], shouldEnforceDefaultChainOnConnect: boolean, privyAppName: string);
    /**
     * The core wallets array that is exposed to developers. It builds
     * the wallets away with the following logic:
     *
     * 1. Flatten all wallets from all connectors
     * 2. Sorted by connectedAt
     * 3. Active wallet is moved to front of array (if it exists)
     */
    get wallets(): BaseConnectedWallet[];
    /**
     * Helper function to find a wallet connector by connector type and wallet client type.
     */
    findWalletConnector(connectorType: ConnectorType, walletClientType: string): WalletConnector | null;
    /**
     * Creates a new wallet connector for the given connector type and wallet client type.
     * If a connector already exists, it will be returned instead.
     */
    createWalletConnector(connectorType: ConnectorType, walletClientType: string, providers?: {
        eip6963InjectedProvider?: EIP6963ProviderDetail;
        legacyInjectedProvider?: any;
    }): Promise<WalletConnector | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getEthereumProvider()).
     *
     * Build an Ethereum provider for the most recently connected wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     *
     * Performing personal_sign with the most recently connected wallet.
     * If there is not a wallet connected, return null.
     */
    activeWalletSign(message: string): Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     */
    setActiveWallet(address: string): void;
}

/**
 * This should not be directly used by developers at the moment,
 * so we doc-ignore it.
 * @ignore
 *
 */
declare class PrivyClient {
    #private;
    private appId;
    private session;
    private timeout;
    api: Http;
    clientAnalyticsId: string | null;
    useServerCookies: boolean;
    apiUrl: string;
    fallbackApiUrl: string;
    authFlow?: AuthFlow;
    connectors?: ConnectorManager;
    onStoreToken?: ((token: string | null) => void) | undefined;
    onDeleteToken?: (() => void) | undefined;
    /**
     * Creates a new Privy client.
     * @param options Initialization options.
     */
    constructor(options: {
        /**
         * The URL of the Privy API. Defaults to `https://api.privy.io/v0`.
         */
        apiUrl?: string;
        /**
         * The app id from your dashboard
         */
        appId: string;
        /**
         * Time in milliseconds after which to timeout requests to the API. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
    });
    /**
     * ConnectorManager initialization is deferred because the input parameter may be overridden by the server
     * config. We can set this once and only once. If it is set twice, event listeners will be created
     * on the first ConnectorManager and are not re-created.
     */
    initializeConnectorManager({ walletConnectCloudProjectId, rpcConfig, chains, defaultChain, store, walletList, shouldEnforceDefaultChainOnConnect, appName, }: {
        walletConnectCloudProjectId: string;
        rpcConfig: RpcConfig;
        chains: Chain[];
        defaultChain: Chain;
        store: Store;
        walletList: WalletListEntry[];
        shouldEnforceDefaultChainOnConnect: boolean;
        appName: string;
    }): void;
    generateApi(): Http;
    /**
     * In the case of cookie-based auth, re-initialize the http client with the custom api url.
     * @param customApiUrl the custom api url to use for cookie-based authFlow
     */
    updateApiUrl(customApiUrl?: string | null): void;
    authenticate(): Promise<{
        user: User | null;
        isNewUser?: boolean | undefined;
        oAuthProviderTokens?: OAuthProviderTokens | undefined;
    }>;
    link(): Promise<User | null>;
    logout(): Promise<void>;
    startAuthFlow<T extends AuthFlow>(authFlow: T): T;
    initMfaSmsVerification(): Promise<void>;
    initMfaPasskeyVerification(): Promise<{
        challenge: string;
        allowCredentials: {
            id: string;
            type: "public-key";
            transports: AuthenticatorTransport[];
        }[];
        timeout: number | undefined;
        extensions: {
            appid: string | undefined;
            credProps: boolean | undefined;
            hmacCreateSecret: boolean | undefined;
        };
        userVerification: UserVerificationRequirement;
    }>;
    unlinkEmail(address: string): Promise<User>;
    acceptTerms(): Promise<User>;
    unlinkPhone(phoneNumber: string): Promise<User>;
    unlinkWallet(address: string): Promise<User>;
    unlinkOAuth(provider: OAuthProviderType, subject: string): Promise<User>;
    unlinkFarcaster(fid: number): Promise<User>;
    unlinkPasskey(credentialId: string): Promise<User>;
    createAnalyticsEvent({ eventName, payload, timestamp, options, }: {
        eventName: string;
        payload?: {
            [key: string]: any;
        };
        timestamp?: Date;
        options?: {
            keepAlive?: boolean;
        };
    }): Promise<void>;
    signMoonpayOnRampUrl(signRequestData: MoonpaySignRequest): Promise<MoonpaySignResponse>;
    /** DATA METHODS */
    /**
     * Fetches the currently authenticed user from the API or
     * returns null if the user is not authenticated.
     *
     * This will refresh the user's access token and rotate
     * the refresh token if needed.
     *
     * @returns Promise<User | null>
     */
    getAuthenticatedUser(): Promise<User | null>;
    /**
     * Grab the Privy access token for the currently logged in user. Verifies that the
     * token has a valid signature, was issued by 'privy.io', and corresponds to the
     * current app ID. If no valid token is found, this method will force a logout and return null.
     *
     * If the token is expired or expiring soon, this will attempt to
     * first refresh the access token to ensure that the token is active. You can
     * disable this behavior using `disableAutoRefresh`, although it is not
     * recommended.
     *
     * @param disableAutoRefresh not recommended - optionally disable automatic
     * token refresh when the token is
     *
     * @returns Promise<string | null>
     */
    getAccessToken(options?: {
        disableAutoRefresh?: boolean;
    }): Promise<string | null>;
    getServerConfig(): Promise<PrivyServerConfig>;
    getUsdTokenPrice(chain: Chain): Promise<number | undefined>;
    requestFarcasterSignerStatus(publicKey: string): Promise<PrivyFarcasterSignerInitResponse>;
    /**
     * Get a short-lived token to start a new Privy session from the existing authenticated session.
     *
     * Rotates the access token and refresh token.
     * Raises an exception if the current session was already forked from a previous session,
     * or if the current session is not authenticated.
     *
     * @returns Promise<string>
     */
    forkSession(): Promise<string>;
}

/**
 * Accepted payment methods for the MoonPay fiat on-ramp.
 */
type MoonpayPaymentMethod = 'ach_bank_transfer' | 'credit_debit_card' | 'gbp_bank_transfer' | 'gbp_open_banking_payment' | 'mobile_wallet' | 'sepa_bank_transfer' | 'sepa_open_banking_payment' | 'pix_instant_payment' | 'yellow_card_bank_transfer';
/**
 * Cryptocurrency codes for the MoonPay fiat on-ramp. These codes
 * follow the format {TOKEN_NAME}_{NETWORK_NAME}.
 */
type MoonpayCurrencyCode = 'AVAX_CCHAIN' | 'CELO_CELO' | 'CUSD_CELO' | 'DAI_ETHEREUM' | 'ETH_ETHEREUM' | 'ETH_ARBITRUM' | 'ETH_POLYGON' | 'ETH_BASE' | 'FIL_FVM' | 'MATIC_ETHEREUM' | 'MATIC_POLYGON' | 'USDC_ETHEREUM' | 'USDC_ARBITRUM' | 'USDC_OPTIMISM' | 'USDC_POLYGON' | 'USDC_BASE' | 'USDT_ETHEREUM' | 'USDT_POLYGON' | 'WETH_POLYGON' | 'WBTC_ETHEREUM' | 'BNB_BNB' | 'BNB_BSC';
/**
 * Configuration parameter for the MoonPay fiat on-ramp.
 */
type MoonpayConfig = {
    currencyCode?: MoonpayCurrencyCode;
    quoteCurrencyAmount?: number;
    paymentMethod?: MoonpayPaymentMethod;
    uiConfig?: {
        accentColor?: string;
        theme?: 'light' | 'dark';
    };
};
type MoonpaySignRequest = {
    address: string;
    config: MoonpayConfig;
    useSandbox: boolean;
};
type MoonpaySignResponse = {
    signedUrl: string;
    externalTransactionId: string;
};

declare const SUPPORTED_OAUTH_PROVIDERS: readonly ["google", "discord", "twitter", "github", "spotify", "instagram", "tiktok", "linkedin", "apple"];
declare const SUPPORTED_MFA_METHODS: readonly ["sms", "totp", "passkey"];
type MfaMethod = (typeof SUPPORTED_MFA_METHODS)[number];
/**
 * Supported OAuth providers. Can be `'google'`, `'discord'`, `'twitter'`, `'github'`, `'spotify'`,
 * `'instagram'`, `'tiktok'`, `'linkedin'`, or `'apple'`
 */
type OAuthProviderType = (typeof SUPPORTED_OAUTH_PROVIDERS)[number];
type LoginMethod = 'email' | 'sms' | 'siwe' | 'farcaster' | OAuthProviderType | 'passkey' | 'telegram';
type LoginWithCode = {
    /**
     * One-time password _([OTP](https://en.wikipedia.org/wiki/One-time_password))_ that was sent to user during first login step
     */
    code: string;
};
declare const EMBEDDED_WALLET_CLIENT_TYPES: readonly ["privy"];
type EmbeddedWalletClientType = (typeof EMBEDDED_WALLET_CLIENT_TYPES)[number];
declare const INJECTED_WALLET_CLIENT_TYPES: readonly ["metamask", "phantom", "brave_wallet", "rainbow", "uniswap_wallet_extension", "rabby_wallet"];
type InjectedWalletClientType = (typeof INJECTED_WALLET_CLIENT_TYPES)[number];
declare const COINBASE_WALLET_CLIENT_TYPES: readonly ["coinbase_wallet"];
type CoinbaseWalletClientType = (typeof COINBASE_WALLET_CLIENT_TYPES)[number];
type WalletConnectWalletClientType = (typeof WALLET_CONNECT_WALLET_CLIENT_TYPES)[number];
declare const UNKNOWN_WALLET_CLIENT_TYPES: readonly ["unknown"];
type UnknownWalletClientType = (typeof UNKNOWN_WALLET_CLIENT_TYPES)[number];
type WalletClientType = InjectedWalletClientType | CoinbaseWalletClientType | WalletConnectWalletClientType | EmbeddedWalletClientType | UnknownWalletClientType;
declare const SUPPORTED_CONNECTOR_TYPES: string[];
type ConnectorType = (typeof SUPPORTED_CONNECTOR_TYPES)[number];
/**
 * Wallet metadata currently for internal use only
 */
type WalletBranding = {
    name: string;
    id: string;
    icon?: string | EmbeddedSVG;
};
type LinkedAccountType = 'wallet' | 'email' | 'phone' | 'google_oauth' | 'twitter_oauth' | 'discord_oauth' | 'github_oauth' | 'spotify_oauth' | 'instagram_oauth' | 'tiktok_oauth' | 'linkedin_oauth' | 'apple_oauth' | 'custom_auth' | 'farcaster' | 'passkey' | 'telegram';
/** @ignore */
interface LinkMetadata {
    /** Account type, most commonly useful when filtering through linkedAccounts */
    type: LinkedAccountType;
    /**
     * @deprecated use `firstVerifiedAt` instead.
     * Datetime when this account was linked to the user or created. */
    verifiedAt: Date;
    /** Datetime when this account was linked to the user. */
    firstVerifiedAt: Date | null;
    /** Datetime when this account was most recently used as a login/link method by the user. */
    latestVerifiedAt: Date | null;
}
/**
 * Optional configuration parameter for the fiat on-ramp.
 */
type FundWalletConfig = {
    config: MoonpayConfig;
    provider?: 'moonpay';
};
/**
 * Possible methods of user-driven recovery.
 * This is set, per app, on the server.
 */
type UserRecoveryMethod = 'user-passcode' | 'google-drive';
/**
 * Object representation of a user's wallet.
 */
interface Wallet {
    /** The wallet address. */
    address: string;
    /**
     * @deprecated Use `chainId` instead.
     *
     * Chain type of the wallet address.
     */
    chainType: 'ethereum' | 'solana';
    /**
     * @deprecated Use `BaseConnectedWallet.chainId` instead.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * // Replace wallets[0] with the wallet you'd like
     * const chainId = wallets[0].chainId;
     * console.log(chainId);
     * // This will be the current chain ID of the wallet,
     * // e.g. 'eip155:1' if the wallet is on mainnet
     * ```
     *
     * Represents the CAIP-2 formatted chain ID of the wallet
     * during the most recent verification during SIWE. May not
     * be up to date with the current chain ID of the wallet.
     *
     * Embedded wallets do not complete SIWE since the user is
     * already authenticated, and you should not use this field
     * for the embedded wallet.
     *
     * e.g. eip155:1, eip155:5, eip155:137, etc.
     */
    chainId?: string;
    /**
     * @deprecated Use `walletClientType` instead.
     */
    walletClient: 'privy' | 'unknown';
    /**
     * The wallet client used for this wallet during the most recent verification.
     *
     * If the value is `privy`, then this is a privy embedded wallet.
     *
     * Other values include but are not limited to `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: string;
    /**
     * The connector type used for this wallet during the most recent verification.
     *
     * This includes but is not limited to `injected`, `wallet_connect`, `coinbase_wallet`, `embedded`.
     */
    connectorType?: string;
    /**
     * If this is a 'privy' embedded wallet, stores the recovery method:
     *
     *     1. 'privy': privy escrow of the recovery material
     *     2. 'user-passcode': recovery protected by user-input passcode
     */
    recoveryMethod?: 'privy' | UserRecoveryMethod;
}
/**
 * Object representation of metadata reported by a connected wallet from a wallet connector
 */
interface ConnectedWalletMetadata {
    /** The wallet name (e.g. MetaMask). */
    name: string;
    /** The wallet RDNS, falls back to the wallet name if none is available. */
    id: string;
    /** The wallet logo */
    icon?: string;
}
/**
 * Object representation of a base connected wallet from a wallet connector.
 */
interface BaseConnectedWallet {
    /** The wallet address. */
    address: string;
    /** The current chain ID with CAIP-2 formatting. */
    chainId: string;
    /** The first time this wallet was connected without break. */
    connectedAt: number;
    /**
     * The wallet client where this key-pair is stored.
     * e.g. metamask, rainbow, coinbase_wallet, etc.
     */
    walletClientType: WalletClientType;
    /**
     * The connector used to initiate the connection with the wallet client.
     * e.g. injected, wallet_connect, coinbase_wallet, etc.
     */
    connectorType: ConnectorType;
    /**
     * Metadata for the wallet.
     */
    meta: ConnectedWalletMetadata;
    /** Returns true if the wallet is connected, false otherwise */
    isConnected: () => Promise<boolean>;
    /**
     * Switch the network chain to a specified ID.
     * Note: The chainId must be a supported network: https://docs.privy.io/guide/frontend/embedded/networks
     * Note: This will not update any existing provider instances, re-request `wallet.getEthersProvider` (e.g.)
     *   to get a provider with the updated chainId.
     *
     * @param targetChainId The specified chain ID to switch to, as a number or 0x prefixed string.
     * @returns void
     */
    switchChain: (targetChainId: `0x${string}` | number) => Promise<void>;
    /** Helper methods to build providers for interfacing with this wallet. */
    getEthereumProvider: () => Promise<EIP1193Provider>;
    getEthersProvider: () => Promise<Web3Provider>;
    getWeb3jsProvider: () => Promise<AbstractProvider>;
    /**
     * Perform personal_sign with the user's wallet.
     *
     * @param {string} message The message to sign.
     * @returns {string} The resulting signature.
     */
    sign: (message: string) => Promise<string>;
    /**
     * @experimental **Experimental**: This property is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Not all wallet clients support programmatic disconnects (e.g. MetaMask, Phantom).
     * In kind, if the wallet's client does not support programmatic disconnects,
     * this method will no-op.
     */
    disconnect: () => void;
}
/**
 * Object representation of a connected wallet.
 */
interface ConnectedWallet extends BaseConnectedWallet {
    /** True if this wallet is linked to the authenticated user. False if it is not yet linked or
     * the user has not yet authenticated. */
    linked: boolean;
    /** Login with this wallet or link this wallet to the authenticated user.
     *
     * Throws a PrivyClientError if the wallet is not connected.
     */
    loginOrLink: () => Promise<void>;
    /** Prompt the user to go through the fiat onramp flow.
     *
     *  This will open the modal with a prompt for the user to navigate to a third-party on-ramp provider.
     *
     *  Once the user continues to the on-ramp flow, Privy will display the on-ramp status screen, and wait
     *  for the transaction to complete.
     *
     *  Note: Even after a successful funding, funds can take a few minutes to arrive in the user's wallet.
     *
     *  The current supported provider is Moonpay.
     *
     *  @param {FundWalletConfig} fundWalletConfig The configuration for the fiat onramp flow.
     * **/
    fund: (fundWalletConfig?: FundWalletConfig) => Promise<void>;
    /** Unlink this wallet to the authenticated user. Throws a PrivyClientError if the user is not
     * authenticated. */
    unlink: () => Promise<void>;
}
/** Object representation of a user's email. */
interface Email {
    /** The email address. */
    address: string;
}
/** Object representation of a user's phone number. */
interface Phone {
    /** The phone number. */
    number: string;
}
/** Object representation of a user's Google account. */
interface Google {
    /** The `sub` claim from the Google-issued JWT for this account. */
    subject: string;
    /** The email associated with the Google account. */
    email: string;
    /** The name associated with the Google account. */
    name: string | null;
}
/** Object representation of a user's Twitter account. */
interface Twitter {
    /** The `sub` claim from the Twitter-issued JWT for this account. */
    subject: string;
    /** The username associated with the Twitter account. */
    username: string | null;
    /** The name associated with the Twitter account. */
    name: string | null;
    /** The profile picture URL associated with the Twitter account.
     *  Note that the Twitter image URL returned is appended with `_normal`
     *  to return a 48x48px image. In order to retrieve the original-sized image,
     *  remove the `_normal` from the URL as specified in the Twitter API docs:
     *  https://developer.twitter.com/en/docs/twitter-api/v1/accounts-and-users/user-profile-images-and-banners
     */
    profilePictureUrl: string | null;
}
/** Object representation of a user's Discord account. */
interface Discord {
    /** The `sub` claim from the Discord-issued JWT for this account. */
    subject: string;
    /** The username associated with the Discord account.  */
    username: string | null;
    /** The email associated with the Discord account. */
    email: string | null;
}
/** Object representation of a user's Github account. */
interface Github {
    /** The `sub` claim from the Github-issued JWT for this account. */
    subject: string;
    /** The username associated with the Github account.  */
    username: string | null;
    /** The name associated with the Github account. */
    name: string | null;
    /** The email associated with the Github account. */
    email: string | null;
}
/** Object representation of a user's Spotify account. */
interface Spotify {
    /** The user id associated with the Spotify account. */
    subject: string;
    /** The email associated with the Spotify account.  */
    email: string | null;
    /** The display name associated with the Spotify account. */
    name: string | null;
}
/** Object representation of a user's Instagram account. */
interface Instagram {
    /** The user id associated with the Instagram account. */
    subject: string;
    /** The username associated with the Instagram account.  */
    username: string | null;
}
/** Object representation of a user's Tiktok account. */
interface Tiktok {
    /** The `sub` claim from the Tiktok-issued JWT for this account. */
    subject: string;
    /** The username associated with the Tiktok account.  */
    username: string | null;
    /** The display name associated with the Tiktok account. */
    name: string | null;
}
/** Object representation of a user's LinkedIn account. */
interface LinkedIn {
    /** The `sub` claim from the LinkedIn-issued JWT for this account. */
    subject: string;
    /** The name associated with the LinkedIn account. */
    name: string | null;
    /** The email associated with the LinkedIn account. */
    email: string | null;
}
/** Object representation of a user's Apple account. */
interface Apple {
    /** The `sub` claim from the Apple-issued JWT for this account. */
    subject: string;
    /** The email associated with the Apple account. */
    email: string;
}
interface CustomJwtAccount {
    /** The user ID given by the custom auth provider */
    customUserId: string;
}
interface Farcaster {
    /** The Farcaster on-chain FID */
    fid: number | null;
    /** The Farcaster ethereum address that owns the FID */
    ownerAddress: string;
    /** The Farcaster protocol username */
    username: string | null;
    /** The Farcaster protocol display name */
    displayName: string | null;
    /** The Farcaster protocol bio */
    bio: string | null;
    /** The Farcaster protocol profile picture */
    pfp: string | null;
    /** The Farcaster protocol profile url */
    url: string | null;
    /** The public key of the signer, if set. This is not guaranteed to be valid, as the user can revoke the key at any time */
    signerPublicKey: string | null;
}
interface Telegram {
    /** The user ID that owns this Telegram account. */
    telegramUserId: string;
    /** The first name of the user . */
    firstName: string | null;
    /** The username associated with the Telegram account. */
    username: string | null;
}
interface Passkey {
    /** The passkey credential ID */
    credentialId: string;
    /** Whether or not this passkey can be used for MFA */
    enrolledInMfa: boolean;
    /** The type of authenticator holding the passkey */
    authenticatorName?: string;
    /** Metadata about the device that registered the passkey  */
    createdWithDevice?: string;
    /** Metadata about the OS that registered the passkey  */
    createdWithOs?: string;
    /** Metadata about the browser that registered the passkey  */
    createdWithBrowser?: string;
}
/** Object representation of a user's email, with additional metadata for advanced use cases. */
interface EmailWithMetadata extends LinkMetadata, Email {
    /** Denotes that this is an email account. */
    type: 'email';
}
/** Object representation of a user's phone number, with additional metadata for advanced use cases. */
interface PhoneWithMetadata extends LinkMetadata, Phone {
    /** Denotes that this is a phone account. */
    type: 'phone';
}
/** Object representation of a user's wallet, with additional metadata for advanced use cases. */
interface WalletWithMetadata extends LinkMetadata, Wallet {
    /** Denotes that this is a wallet account. */
    type: 'wallet';
}
/** Object representation of a user's Google Account, with additional metadata for advanced use cases. */
interface GoogleOAuthWithMetadata extends LinkMetadata, Google {
    /** Denotes that this is a Google account. */
    type: 'google_oauth';
}
/** Object representation of a user's Twitter Account, with additional metadata for advanced use cases. */
interface TwitterOAuthWithMetadata extends LinkMetadata, Twitter {
    /** Denotes that this is a Twitter account. */
    type: 'twitter_oauth';
}
/** Object representation of a user's Discord Account, with additional metadata for advanced use cases. */
interface DiscordOAuthWithMetadata extends LinkMetadata, Discord {
    /** Denotes that this is a Discord account. */
    type: 'discord_oauth';
}
/** Object representation of a user's Github Account, with additional metadata for advanced use cases. */
interface GithubOAuthWithMetadata extends LinkMetadata, Github {
    /** Denotes that this is a Github account. */
    type: 'github_oauth';
}
/** Object representation of a user's Tiktok Account, with additional metadata for advanced use cases. */
interface SpotifyOAuthWithMetadata extends LinkMetadata, Spotify {
    /** Denotes that this is a Tiktok account. */
    type: 'spotify_oauth';
}
/** Object representation of a user's Instagram Account, with additional metadata for advanced use cases. */
interface InstagramOAuthWithMetadata extends LinkMetadata, Instagram {
    /** Denotes that this is a Instagram account. */
    type: 'instagram_oauth';
}
/** Object representation of a user's Tiktok Account, with additional metadata for advanced use cases. */
interface TiktokOAuthWithMetadata extends LinkMetadata, Tiktok {
    /** Denotes that this is a Tiktok account. */
    type: 'tiktok_oauth';
}
/** Object representation of a user's LinkedIn Account, with additional metadata for advanced use cases. */
interface LinkedInOAuthWithMetadata extends LinkMetadata, LinkedIn {
    /** Denotes that this is a LinkedIn account. */
    type: 'linkedin_oauth';
}
/** Object representation of a user's Apple Account, with additional metadata for advanced use cases. */
interface AppleOAuthWithMetadata extends LinkMetadata, Apple {
    /** Denotes that this is a Apple account. */
    type: 'apple_oauth';
}
/** Object representation of a user's Custom JWT Account, with additional metadata for advanced use cases. */
interface CustomJwtAccountWithMetadata extends LinkMetadata, CustomJwtAccount {
    /** Denotes that this is an custom account. */
    type: 'custom_auth';
}
/** Object representation of a user's Farcaster Account, with additional metadata for advanced use cases. */
interface FarcasterWithMetadata extends LinkMetadata, Farcaster {
    /** Denotes that this is a Farcaster account. */
    type: 'farcaster';
}
/** Object representation of a user's Passkey Account, with additional metadata for advanced use cases. */
interface PasskeyWithMetadata extends LinkMetadata, Passkey {
    /** Denotes that this is a Passkey account. */
    type: 'passkey';
}
/** Object representation of a user's Telegram Account, with additional metadata for advanced use cases. */
interface TelegramWithMetadata extends LinkMetadata, Telegram {
    /** Denotes that this is a Telegram account. */
    type: 'telegram';
}
/**
 * Object representation of a user's linked accounts
 */
type LinkedAccountWithMetadata = WalletWithMetadata | EmailWithMetadata | PhoneWithMetadata | GoogleOAuthWithMetadata | TwitterOAuthWithMetadata | DiscordOAuthWithMetadata | GithubOAuthWithMetadata | SpotifyOAuthWithMetadata | InstagramOAuthWithMetadata | TiktokOAuthWithMetadata | LinkedInOAuthWithMetadata | AppleOAuthWithMetadata | CustomJwtAccountWithMetadata | FarcasterWithMetadata | PasskeyWithMetadata | TelegramWithMetadata;
interface User {
    /** The Privy-issued DID for the user. If you need to store additional information
     * about a user, you can use this DID to reference them. */
    id: string;
    /** The datetime of when the user was created. */
    createdAt: Date;
    /** The user's email address, if they have linked one. It cannot be linked to another user. */
    email?: Email;
    /** The user's phone number, if they have linked one. It cannot be linked to another user. */
    phone?: Phone;
    /** The user's most recently linked wallet, if they have linked at least one wallet.
     *  It cannot be linked to another user.
     *  This wallet is the wallet that will be used for transactions and signing if it is connected.
     **/
    wallet?: Wallet;
    /** The user's Google account, if they have linked one. It cannot be linked to another user. */
    google?: Google;
    /** The user's Twitter account, if they have linked one. It cannot be linked to another user. */
    twitter?: Twitter;
    /** The user's Discord account, if they have linked one. It cannot be linked to another user. */
    discord?: Discord;
    /** The user's Github account, if they have linked one. It cannot be linked to another user. */
    github?: Github;
    /** The user's Spotify account, if they have linked one. It cannot be linked to another user. */
    spotify?: Spotify;
    /** The user's Instagram account, if they have linked one. It cannot be linked to another user. */
    instagram?: Instagram;
    /** The user's Tiktok account, if they have linked one. It cannot be linked to another user. */
    tiktok?: Tiktok;
    /** The user's LinkedIn account, if they have linked one. It cannot be linked to another user. */
    linkedin?: LinkedIn;
    /** The user's Apple account, if they have linked one. It cannot be linked to another user. */
    apple?: Apple;
    /** The user's Farcaster account, if they have linked one. It cannot be linked to another user. */
    farcaster?: Farcaster;
    /** The user's Telegram account, if they have linked one. It cannot be linked to another user. */
    telegram?: Telegram;
    /** The list of accounts associated with this user. Each account contains additional metadata
     * that may be helpful for advanced use cases. */
    linkedAccounts: Array<LinkedAccountWithMetadata>;
    /** The list of MFA Methods associated with this user. */
    mfaMethods: Array<MfaMethod>;
    /**
     * Whether or not the user has explicitly accepted the Terms and Conditions
     * and/or Privacy Policy
     */
    hasAcceptedTerms: boolean;
}
type OAuthProviderTokens = {
    /** The OAuth provider. */
    provider: OAuthProviderType;
    /** The OAuth access token. */
    accessToken: string;
    /** The number of seconds until the OAuth access token expires. */
    accessTokenExpiresInSeconds?: number;
    /** The OAuth refresh token. */
    refreshToken?: string;
    /** The list of OAuth scopes the access token is approved for. */
    scopes?: string[];
};
type TelegramAuthConfiguration = {
    botId: string;
    botName: string;
};
type PrivyServerConfig = {
    id?: string;
    name?: string;
    verificationKey?: string;
    showWalletLoginFirst?: boolean;
    allowlistConfig: AllowlistConfig;
    walletAuth?: boolean;
    emailAuth?: boolean;
    smsAuth?: boolean;
    googleOAuth?: boolean;
    twitterOAuth?: boolean;
    discordOAuth?: boolean;
    githubOAuth?: boolean;
    spotifyOAuth?: boolean;
    instagramOAuth?: boolean;
    tiktokOAuth?: boolean;
    linkedinOAuth?: boolean;
    appleOAuth?: boolean;
    farcasterAuth?: boolean;
    passkeyAuth?: boolean;
    telegramAuth?: boolean;
    termsAndConditionsUrl: string | null;
    privacyPolicyUrl: string | null;
    requireUsersAcceptTerms?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    customApiUrl?: string | null;
    walletConnectCloudProjectId?: string | null;
    embeddedWalletConfig: EmbeddedWalletsConfig;
    fiatOnRampEnabled?: boolean;
    captchaEnabled?: boolean;
    captchaSiteKey: string;
    twitterOAuthOnMobileEnabled?: boolean;
    enforceWalletUis?: boolean;
    legacyWalletUiConfig?: boolean;
    /** May be deprecated from the server config in a future release */
    logoUrl?: string;
    /** May be deprecated from the server config in a future release */
    accentColor?: string;
    mfaMethods?: Array<MfaMethod>;
    telegramAuthConfiguration?: TelegramAuthConfiguration;
};
type HexColor = `#${string}`;
/**
 * Options to customize the display of transaction prices in the embedded wallet's transaction prompt.
 */
type PriceDisplayOptions = {
    primary: 'fiat-currency';
    secondary: 'native-token';
} | {
    primary: 'native-token';
    secondary: null;
};
type WalletListEntry = 'metamask' | 'coinbase_wallet' | 'rainbow' | 'phantom' | 'zerion' | 'cryptocom' | 'uniswap' | 'okx_wallet' | 'detected_wallets' | 'wallet_connect' | 'rabby_wallet';
type NonEmptyArray<T> = [T, ...T[]];
type LoginMethodOrderOption = 'email' | 'sms' | WalletListEntry | OAuthProviderType | 'farcaster' | 'telegram';
interface PrivyClientConfig {
    /** All UI and theme related configuration */
    appearance?: {
        /** Primary theme for the privy UI. This dictates the foreground and background colors within the UI.
         *
         *  'light' (default): The privy default light UI.
         *  'dark': The privy default dark UI.
         *  custom hex code (i.e. '#13152F'): A custom background. This will generate the remainder of the foreground and
         *  background colors for the UI by modulating the luminance of the passed color. This value should be _either_ dark
         *  or light (<20% or >80% luminance), for accessibility. */
        theme?: 'light' | 'dark' | HexColor;
        /** Accent color for the privy UI.
         *  Used for buttons, active borders, etc. This will generate light and dark variants.
         *  This overrides the server setting `accent_color`. */
        accentColor?: HexColor;
        /** Logo for the main privy modal screen.
         *  This can be a string (url) or an img / svg react element.
         *  If passing an element, Privy will overwrite the `style` props, to ensure proper rendering.
         *  This overrides the server setting `logo_url` */
        logo?: string | ReactElement;
        /**
         * Header text for the landing screen of the Privy login modal. We strongly recommend using a string
         *  of length 35 or less. Strings longer than the width of the login modal will be ellipsified.
         *
         * Defaults to 'Log in or sign up'.
         */
        landingHeader?: string;
        /** Determines the order of the login options in the privy modal. If true, the wallet login will render above
         *  social and email / sms login options.
         *  This overrides the server setting `show_wallet_login_first` */
        showWalletLoginFirst?: boolean;
        /**
         * An array of {@link WalletListEntry wallet names} to configure the wallet buttons shown within
         * the `login`, `connectWallet`, and `linkWallet` modals. Privy will show buttons for each option
         * present in the list, in the order in which they are configured.
         *
         * On 'detected_wallets':
         * - This option serves as a fallback to include all wallets that detected by Privy, that might not be
         *   individually configured in the `walletList`. Browser extension wallets that are not explicitly configured
         *   in the `walletList` will fall into this category.
         * - If Privy detects a wallet, _and_ that wallet is configured within the `walletList` (e.g. 'metamask'),
         *   the order of the wallet's explicit name (e.g. 'metamask') in the `walletList` will take priority
         *   over the order of 'detected_wallets'.
         *
         * Defaults to ['detected_wallets', 'metamask', 'coinbase', 'rainbow', 'wallet_connect']
         *
         * @default ['detected_wallets', 'metamask', 'coinbase', 'rainbow', 'wallet_connect']
         */
        walletList?: WalletListEntry[];
    };
    /**
     * Login methods for the privy modal.
     *
     * This parameter enables you to display a subset of the login methods specified in the developer dashboard. `loginMethods` cannot be an empty array if specified. The order of this array does not  dictate order of the login methods in the UI.
     *
     * Note that any login method included in this parameter must also be enabled as a login method in the developer dashboard.
     *
     * If both `loginMethodsAndOrder` and `loginMethods` are defined, `loginMethodsAndOrder` will take precedence.
     */
    loginMethods?: Array<'wallet' | 'email' | 'sms' | 'google' | 'twitter' | 'discord' | 'github' | 'linkedin' | 'spotify' | 'instagram' | 'tiktok' | 'apple' | 'farcaster' | 'telegram'>;
    /**
     * Login methods for the Privy modal. _This will override carefully designed defaults and should be used with caution._
     *
     * This parameter enables you to display a subset of the login methods specified in the developer dashboard. Login methods will be rendered in the order they appear in the array. The first 4 options specified in the `primary` list will render on the default screen of the login experience. Options in the `overflow` list will appear on the following screen.
     *
     * Note that any login method included in this parameter must also be enabled as a login method in the developer dashboard.
     *
     * If both `loginMethodsAndOrder` and `loginMethods` are defined, `loginMethodsAndOrder` will take precedence.
     */
    loginMethodsAndOrder?: {
        primary: NonEmptyArray<LoginMethodOrderOption>;
        overflow?: Array<LoginMethodOrderOption>;
    };
    /** Options for internationalization of the privy modal */
    intl?: {
        /**
         * This property is used to configure formatting and validation for the phone number input
         * used when `phone` is enabled as a login method. Must be a valid
         * [two-leter ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (e.g. 'US').
         * Defaults to 'US'.
         *
         * @default 'US'
         */
        defaultCountry: CountryCode;
    };
    /**
     * This property is only required for apps that use a third-party authentication provider.
     */
    customAuth?: {
        /**
         * If true, enable custom authentication integration.
         * This enables a JWT from a custom auth provider to be used to authenticate Privy embedded wallets.
         * Defaults to true.
         *
         * @default true
         */
        enabled?: boolean;
        /**
         * A callback that returns the user's custom auth provider's access token as a string.
         * Can be left blank if using cookies to store and send access tokens
         *
         * @example
         * const {getAccessTokenSilently} = useAuth();
         *
         * <PrivyProvider
         *   {...props}
         *   config={{
         *     customAuth: {
         *       getCustomAccessToken: getAccessTokenSilently
         *     },
         *   }}
         * />
         */
        getCustomAccessToken: () => Promise<string | undefined>;
        /**
         * Custom auth providers loading state
         *
         * @example
         * const {isLoading} = useAuth();
         *
         * <PrivyProvider
         *   {...props}
         *   config={{
         *     customAuth: {
         *       isLoading,
         *     },
         *   }}
         * />
         */
        isLoading: boolean;
    };
    /** All legal configuration */
    legal?: {
        /** URL to the terms and conditions page for your application.
         *  Rendered as a link in the privy modal footer.
         *  This overrides the server setting `terms_and_conditions_url` */
        termsAndConditionsUrl?: string | null;
        /** URL to the privacy policy page for your application.
         *  Rendered as a link in the privy modal footer.
         *  This overrides the server setting `privacy_policy_url` */
        privacyPolicyUrl?: string | null;
    };
    walletConnectCloudProjectId?: string;
    /**
     * @deprecated use `supportedChains[number].rpcUrls.privyWalletOverride` instead.
     *
     * RPC overrides to customize RPC URLs and timeout durations.
     */
    rpcConfig?: RpcConfig;
    /**
     * @deprecated use `supportedChains` instead.
     *
     */
    additionalChains?: Chain[];
    /**
     * A list of supported chains, used to specify which chains should be used throughout the application.
     *
     * Calling `sendTransaction` or `switchChain` on an unsupported network will throw an error.
     *
     * For external wallets, if the wallet's current chain post-connection (during connect-only or siwe flows)
     * is not within the supported chains list, the user will be prompted to switch to the `defaultChain` (if set) or first supplied. If the chain
     * switching process does not fully succeed, the user will **not** be blocked from the application (and the wallet's current `chainId` can always
     * be observed and acted upon accordingly).
     *
     * For embedded wallets, the wallet will automatically default to the `defaultChain` (if set) or first supplied `supportedChain`.
     */
    supportedChains?: Chain[];
    /**
     * When supplied, the `defaultChain` will be the default chain used throughout the application.
     *
     * For external wallets, it will be used if the user's wallet it not within the `supportedChains` (or default chains) list.
     *
     * For embedded wallets, it will be used upon initialization, when the user hasn't switched to another supported chain.
     */
    defaultChain?: Chain;
    captchaEnabled?: boolean;
    /** All embedded wallets configuration */
    embeddedWallets?: {
        /**
         * Whether an embedded wallet should be created for the user on login. This overrides the
         * deprecated `createPrivyWalletOnLogin`.
         *
         * For `all-users`, the user will be prompted to create a Privy wallet after successfully
         * logging in. If they cancel or are visiting after this flag was put in place, they will be
         * prompted to create a wallet on their next login.
         *
         * For `users-without-wallets`, the user will be prompted to create a Privy wallet after\
         * successfully logging in, only if they do not currently have any wallet associated with their
         * user object - for example if they have linked an external wallet.
         *
         * For `off`, an embedded wallet is not created during login. You can always prompt the user to
         * create one manually with your app.
         *
         * Defaults to 'off'.
         */
        createOnLogin?: EmbeddedWalletCreateOnLoginConfig;
        /**
         * @deprecated. Instead, use the server-driven configuration found in the Privy console: https://dashboard.privy.io/apps/YOUR_APP_ID/embedded. This client-side setting
         * is currently honored, but will be fully removed in a future release.
         *
         * If true, Privy will prompt users to create a password for their Privy embedded wallet.
         * If false, embedded wallets will be created without the need of password.
         *
         * Defaults to false.
         */
        requireUserPasswordOnCreate?: boolean;
        /**
         * @deprecated. Instead, use the server-driven configuration found in the Privy console: https://dashboard.privy.io/apps/YOUR_APP_ID/embedded.
         * If true, Privy will not prompt or instantiate any UI for embedded wallet signatures and transactions.
         * If false, embedded wallet actions will raise a modal and require user confirmation to proceed.
         *
         * Defaults to false.
         */
        noPromptOnSignature?: boolean;
        /**
         * @experimental
         *
         * **This setting is only honored when using the EIP-1193 Ethereum Provider to interface
         * with the embedded wallet, i.e. using `getEthereumProvider` or `getEthersProvider`.
         * This setting is only honored when used alongside `noPromptOnSignature: true`**
         *
         * If true, calls to `sendTransaction` will wait for the transaction to be confirmed before resolving.
         * If false, calls to `sendTransaction` will resolve once the transaction has been submitted.
         *
         * Defaults to true.
         *
         * @example
         * <PrivyProvider
         *   config={{
         *     embeddedWallets: {
         *       noPromptOnSignature: true,
         *       waitForTransactionConfirmation: false,
         *     },
         *   }}
         * >
         *   {children}
         * </PrivyProvider>
         */
        waitForTransactionConfirmation?: boolean;
        /**
         * Options to customize the display of transaction prices in the embedded wallet's transaction
         * prompt. You may configure a primary currency to emphasize, and a secondary currency to show
         * as subtext. Defaults to emphasizing the price in fiat currency, and showing the price in the native
         * token as subtext.
         *
         * You may either set:
         * - `{primary: 'fiat-currency', secondary: 'native-token'}` to emphasize fiat currency prices, showing native token
         *    prices as subtext. This is the default.
         * - `{secondary: 'native-token', secondary: null}` to show native token prices only, with no subtext.
         *
         * Privy does not currently support:
         * - emphasizing native token prices over fiat currency prices
         * - showing prices only in fiat currency, without native token prices
         *
         */
        priceDisplay?: PriceDisplayOptions;
    };
    /**
     * All multi-factor authentication configuration
     */
    mfa?: {
        /**
         * If true, Privy will not prompt or instantiate any UI for MFA Verification. The developer
         * must handle MFA verification themselves.
         * If false, any action that requires MFA will raise a modal and require user to verify MFA
         * before proceeding.
         *
         * Defaults to false.
         */
        noPromptOnMfaRequired?: boolean;
    };
    /**
     * Setting associated with fiat-on-ramp flows
     */
    fiatOnRamp?: {
        /**
         * Determines whether to use the sandbox flow.
         *
         * Defaults to false.
         */
        useSandbox?: boolean;
    };
}
interface AllowlistConfig {
    errorTitle: string | null;
    errorDetail: string | null;
    errorCtaText: string | null;
    errorCtaLink: string | null;
}
type EmbeddedWalletCreateOnLoginConfig = 'users-without-wallets' | 'all-users' | 'off';
interface EmbeddedWalletsConfig {
    createOnLogin: EmbeddedWalletCreateOnLoginConfig;
    requireUserOwnedRecoveryOnCreate: boolean;
    userOwnedRecoveryOptions: UserRecoveryMethod[];
}
type OtpFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'sending-code';
} | {
    status: 'awaiting-code-input';
} | {
    status: 'submitting-code';
} | {
    status: 'done';
};
/**
 * UI configuration object for the embedded wallet's Sign Message screen
 */
type SignMessageModalUIOptions = {
    /**
     * Title for the Sign Message screen. Defaults to 'Sign'.
     */
    title?: string;
    /**
     * Description text for the Sign Message screen. Defaults to
     * 'Sign to continue'.
     */
    description?: string;
    /**
     * Text for the CTA button on the Sign Message screen. Defaults to
     * 'Sign and Continue'
     */
    buttonText?: string;
};
type MessageTypeProperty = {
    name: string;
    type: string;
};
type MessageTypes = {
    [additionalProperties: string]: MessageTypeProperty[];
};
/**
 * JSON Object that conforms to the EIP-712 [`TypedData JSON schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
 *
 */
type TypedMessage<T extends MessageTypes> = {
    types: T;
    primaryType: keyof T;
    domain: {
        name?: string;
        version?: string;
        chainId?: number;
        verifyingContract?: string;
        salt?: ArrayBuffer;
    };
    message: Record<string, unknown>;
};
/**
 * JSON Object that conforms to the EIP-712 [`TypedData JSON schema.`](https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc)
 * See [`TypedMessage`](TypedMessage) for specs on the specific params of typedData.
 */
type SignTypedDataParams = TypedMessage<MessageTypes>;
/**
 * UI customization object for additional transaction details. Will be shown
 * in an expandable accordion in the Send Transaction screen.
 */
type TransactionUIOptions = {
    /**
     * Title for the transaction details accordion within the
     * Send Transaction screen. Defaults to 'Details'.
     */
    title?: string;
    /**
     * Action that the user is taking when sending this transaction. This
     * should be short (<4 words, e.g. 'Buy NFT'). Will be shown inside
     * the transaction details accordion in Send Transaction screen.
     */
    action?: string;
    /**
     * If the transaction to be sent is a call to a smart contract, you may
     * use this object to fill in additional details about the contract being called.
     */
    contractInfo?: ContractUIOptions;
    /**
     * @deprecated Use `description` in `SendTransactionModalUIOptions` instead.
     */
    description?: string;
    /**
     * @deprecated Use `title` instead.
     */
    actionDescription?: string;
};
/**
 * If the transaction to be sent is a call to a smart contract, you may use this
 * object to fill in additional details about the contract being called.
 */
type ContractUIOptions = {
    /**
     * URL with more information about the smart contract.
     */
    url?: string;
    /**
     * Name of smart contract being called.
     */
    name?: string;
    /**
     * URL for an image to show in the Send Transaction screen.
     */
    imgUrl?: string;
    /**
     * Alt text for the image in the Send Transaction screen, if a
     * valid `imgUrl` is set.
     */
    imgAltText?: string;
    /**
     * Size for the image in the Send Transaction screen, if a valid
     * `imgUrl` is set.
     */
    imgSize?: 'sm' | 'lg';
    /**
     * @deprecated Use `description` in `SendTransactionModalUIOptions` instead.
     */
    actionText?: string;
};
/**
 * UI customization object for the embedded wallet's Send Transaction screen
 */
type SendTransactionModalUIOptions = {
    /**
     * Text to display at top of Send Transaction screen. Defaults to
     * 'Review transaction' or 'Send (insert token symbol)' if transaction
     * is a simple token transfer.
     */
    header?: string;
    /**
     * Description of the transaction being sent.
     */
    description?: string;
    /**
     * Text to show on CTA button for Send Transaction screen. Defaults to
     * 'Submit'.
     */
    buttonText?: string;
    /**
     * Details about the transaction that the user will send. Will be shown
     * in an accordion in the Send Transaction screen.
     */
    transactionInfo?: TransactionUIOptions;
    /**
     * Text to display at top of Send Transaction Success screen. Defaults to
     * 'Transaction complete!' if transaction is successful.
     */
    successHeader?: string;
    /**
     * Description of the transaction Success screen. Defaults to 'You're all set.'
     */
    successDescription?: string;
    /**
     * @deprecated Use `header` instead.
     */
    title?: string;
    /**
     * @deprecated Use `header` instead.
     */
    modalTitle?: string;
    /**
     * @deprecated Use `transactionInfo.contractInfo` instead.
     */
    senderInfo?: ContractUIOptions;
};
type PrivyFarcasterSignerInitResponse = {
    public_key: string;
    status: 'pending_approval';
    signer_approval_url: string;
} | {
    public_key: string;
    status: 'approved';
    fid: bigint;
} | {
    public_key: string;
    status: 'revoked';
};

declare function getAccessToken(): Promise<string | null>;
/**
 * Properties to initialize the {@link PrivyProvider}.
 */
interface PrivyProviderProps {
    /** Your Privy App ID, which can be retrieved from the Privy dashboard. */
    appId: string;
    /**
     * An optional callback that will execute once a `login` call successfully completes.
     *
     * Within this callback, you can access:
     * - the `user` object corresponding to the authenticated user
     * - an `isNewUser` boolean flag indicating if this is the user's first time logging in to your app
     *
     */
    onSuccess?: (user: User, isNewUser: boolean) => void;
    /**
     * @deprecated use `config.embeddedWallets.createOnLogin` instead
     */
    createPrivyWalletOnLogin?: boolean;
    /**
     * Client configuration options.
     * Values here will override their server-configuration counterparts.
     */
    config?: PrivyClientConfig;
    /**
     * @ignore
     * @class
     */
    children: react.ReactNode;
}
/**
 * Passes the Privy authentication context to your React components.
 *
 * This should wrap any components that will to use the Privy SDK via the {@link usePrivy} hook. As an example:
 *
 * ```typescript
 * // At your application root (e.g. `_app.tsx` in NextJS):
 * import {PrivyProvider} from '@privy-io/react-auth';
 *
 * <PrivyProvider appId="APP_ID_FROM_DASHBOARD" onSuccess={() => console.log('Success!')}>
 *   <Component {...pageProps} />
 * </PrivyProvider>
 * ```
 *
 */
declare const PrivyProvider: ({ config, ...props }: PrivyProviderProps) => JSX.Element;

type CaptchaProps = Partial<Pick<TurnstileProps, 'onUnsupported' | 'onError' | 'onSuccess' | 'onExpire' | 'onSubmit'>> & {
    delayedExecution?: boolean;
};
/**
 * Used to render an invisible captcha alongside important forms
 *
 * Notes:
 * - **Only for internal use, or use with headless SDK** _(the Privy modal handles captchas internally with this component)_
 * - Only one `<Captcha />` should be rendered at a time, since it injects/removes a global script
 * - the state of the captcha workflow can be accessed using `useCaptcha`
 * - wrapper around [marsidev/react-turnstile](https://github.com/marsidev/react-turnstile), _accepts same [props](https://docs.page/marsidev/react-turnstile/props)_
 */
declare const Captcha: (props: CaptchaProps) => react_jsx_runtime.JSX.Element | null;

/**
 * Allows you to manage the user's current authentication state and access their linked accounts.
 * You can access the fields and methods documented here via the {@link usePrivy} hook.
 */
interface PrivyInterface {
    /**
     * Check whether the `PrivyProvider` is ready to be used. You should wait for this to
     * be true before using values such as `authenticated` and `user`.
     */
    ready: boolean;
    /**
     * True if the user is authenticated, false otherwise.
     *
     * You should always check that `ready` is true before using this value. Otherwise,
     * the value may outdated while the Privy client fetches fresh tokens.
     *
     */
    authenticated: boolean;
    /**
     * The user object, or null if the user is not authenticated.
     */
    user: User | null;
    /**
     * Opens the Privy modal and prompts the user to connect a wallet.
     */
    connectWallet: () => void;
    /**
     * Opens the Privy login modal and prompts the user to login.
     */
    login: () => void;
    /**
     * Opens the Privy login modal and prompts the user to login or connect a wallet.
     */
    connectOrCreateWallet: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link an email.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkEmail: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a phone number.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkPhone: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a wallet.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkWallet: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a Farcaster account.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkFarcaster: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Google OAuth account.
     * This will directly initiate the OAuth flow for Google.
     */
    linkGoogle: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Twitter OAuth account
     * This will directly initiate the OAuth flow for Twitter.
     */
    linkTwitter: () => void;
    /**
     * For users who are authenticated, prompts the user to link Discord OAuth account
     * This will directly initiate the OAuth flow for Discord.
     */
    linkDiscord: () => void;
    /**
     * For users who are authenticated, prompts the user to link Github OAuth account
     * This will directly initiate the OAuth flow for Github.
     */
    linkGithub: () => void;
    /**
     * For users who are authenticated, prompts the user to link Spotify OAuth account
     * This will directly initiate the OAuth flow for Spotify.
     */
    linkSpotify: () => void;
    /**
     * For users who are authenticated, prompts the user to link Instagram OAuth account
     * This will directly initiate the OAuth flow for Instagram.
     */
    linkInstagram: () => void;
    /**
     * For users who are authenticated, prompts the user to link Tiktok OAuth account
     * This will directly initiate the OAuth flow for Tiktok.
     */
    linkTiktok: () => void;
    /**
     * For users who are authenticated, prompts the user to link LinkedIn OAuth account
     * This will directly initiate the OAuth flow for LinkedIn.
     */
    linkLinkedIn: () => void;
    /**
     * For users who are authenticated, prompts the user to link Apple OAuth account
     * This will directly initiate the OAuth flow for Apple.
     */
    linkApple: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Passkey account
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkPasskey: () => void;
    /**
     * For users who are authenticated and have already linked an email address, prompts the user to update their email address.
     * This will open the Privy Modal which will guide the user through this action.
     *
     */
    updateEmail: () => void;
    /**
     * Log the current user out and clears their authentication state. `authenticated` will become false, `user` will become null, and the Privy Auth tokens will be deleted from the browser's local storage.
     *
     * You may await this call to take an action once logout is complete (e.g. redirecting to a specific page).
     */
    logout: () => Promise<void>;
    /**
     * Get the Privy access token ([JWT](https://jwt.io/)) for an authenticated user. Returns null for an unauthenticated user.
     *
     * You may use this token to authorize requests sent from your frontend, and can validate it in your backend against your app's Privy verification key.
     *
     * This will automatically attempt to refresh the session if the token is expired or about to expire.
     *
     * @returns Promise for the user's access token as a string if they are authenticated, null if they are unauthenticated.
     */
    getAccessToken: () => Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This method will be deprecated and should be replaced by calling `getEthereumProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getEthereumProvider();
     * ```
     *
     *
     * Gets an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193)-compatible provider from the user's wallet, if the user has connected one.
     *
     * You may then use the Ethereum Javascript API syntax to send JSON-RPC requests to the user's wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This method will be deprecated and should be replaced by calling `getEthersProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getEthersProvider();
     * ```
     *
     * Get an [ethers.js](https://docs.ethers.io/v5/)-compatible provider from the user's wallet, if the user has connected one.
     *
     */
    getEthersProvider: () => Web3Provider;
    /**
     * @deprecated **Deprecated**: This feature will be deprecated and should be replaced by calling `getWeb3jsProvider`
     * directly on the `ConnectedWallet` objects returned by the `useWallets` hook, e.g.
     *
     * ```tsx
     * const {wallets} = useWallets();
     * const provider = await wallets[0].getWeb3jsProvider();
     * ```
     *
     * Get a [web3.js](https://web3js.readthedocs.io/en/v1.8.0/)-compatible provider from the user's wallet, if the user has connected one.
     */
    getWeb3jsProvider: () => AbstractProvider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by the
     * `useWallets` hook.
     *
     * Get the ConnectorManager object
     * This shouldn't need to be used directly unless creating a plugin, like a WAGMI plugin
     */
    walletConnectors: ConnectorManager | null;
    /**
     * Unlink an email account from a user, by passing the email address. Note that you can only unlink an email account if the user has at least one other account.
     *
     * @param address {string} email address to be unlinked
     * @returns Promise for the {@link User} object after the provided email has been unlinked
     */
    unlinkEmail: (address: string) => Promise<User>;
    /**
     * Unlink a phone account from a user, by passing the phone number. Note that you can only unlink a phone account if the user has at least one other account.
     *
     * @param phoneNumber {string} phone number to be unlinked
     * @returns Promise for the {@link User} object after the provided phone number has been unlinked
     */
    unlinkPhone: (phoneNumber: string) => Promise<User>;
    /**
     * Unlink a wallet account from a user, by passing the public address. Note that you can only unlink a wallet account if the user has at least one other account.
     * If the unlinked wallet was the active one, and more wallets are linked to the user, then we attempt to make the most recently linked wallet active.
     *
     * @param address {string} wallet address to be unlinked
     * @returns Promise for the {@link User} object after the provided wallet has been unlinked
     */
    unlinkWallet: (address: string) => Promise<User>;
    /**
     * Unlink a Google social account from a user, by passing the google subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} google account's subject ID
     * @returns Promise for the {@link User} object after the provided Google account has been unlinked
     */
    unlinkGoogle: (subject: string) => Promise<User>;
    /**
     * Unlink a Twitter social account from a user, by passing the twitter subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} twitter account's subject ID
     * @returns Promise for the {@link User} object after the provided Twitter account has been unlinked
     */
    unlinkTwitter: (subject: string) => Promise<User>;
    /**
     * Unlink a Discord social account from a user, by passing the discord subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} discord account's subject ID
     * @returns Promise for the {@link User} object after the provided Discord account has been unlinked
     */
    unlinkDiscord: (subject: string) => Promise<User>;
    /**
     * Unlink a Github social account from a user, by passing the github subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} github account's subject ID
     * @returns Promise for the {@link User} object after the provided Github account has been unlinked
     */
    unlinkGithub: (subject: string) => Promise<User>;
    /**
     * Unlink a Spotify social account from a user, by passing the spotify subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} spotify account's subject ID
     * @returns Promise for the {@link User} object after the provided Spotify account has been unlinked
     */
    unlinkSpotify: (subject: string) => Promise<User>;
    /**
     * Unlink a Instagram social account from a user, by passing the instagram subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} instagram account's subject ID
     * @returns Promise for the {@link User} object after the provided Instagram account has been unlinked
     */
    unlinkInstagram: (subject: string) => Promise<User>;
    /**
     * Unlink a Tiktok social account from a user, by passing the tiktok subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} tiktok account's subject ID
     * @returns Promise for the {@link User} object after the provided Tiktok account has been unlinked
     */
    unlinkTiktok: (subject: string) => Promise<User>;
    /**
     * Unlink a LinkedIn social account from a user, by passing the linkedin subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} linkedin account's subject ID
     * @returns Promise for the {@link User} object after the provided LinkedIn account has been unlinked
     */
    unlinkLinkedIn: (subject: string) => Promise<User>;
    /**
     * Unlink a Apple social account from a user, by passing the apple subject ID. Note that you can only unlink a social account if the user has at least one other account.
     *
     * @param subject {string} apple account's subject ID
     * @returns Promise for the {@link User} object after the provided Apple account has been unlinked
     */
    unlinkApple: (subject: string) => Promise<User>;
    /**
     * Unlink a Farcaster account from a user, by passing the FID. Note that you can only unlink a phone account if the user has at least one other account.
     *
     * @param fid {number} Farcaster ID
     * @returns Promise for the {@link User} object after the provided Farcaster account has been unlinked
     */
    unlinkFarcaster: (fid: number) => Promise<User>;
    /**
     * Unlink a Passkey account from a user, by passing the credential ID. Note that you can only unlink a passkey account if the user has at least one other account.
     *
     * @param credentialId {string} Passkey Credential ID
     * @returns Promise for the {@link User} object after the provided passkey account has been unlinked
     */
    unlinkPasskey: (credentialId: string) => Promise<User>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and behaves the same as connectWallet(). Instead, please
     * interact with the wallets array directly.
     *
     * Note that when you connect a new wallet, it becomes first in the wallets array.
     */
    setActiveWallet: (address: string) => Promise<void>;
    /**
     * @experimental **Experimental**: This feature is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Get a short-lived, one-time-use token to start a new Privy session from the existing authenticated session. Raises an exception if the current session was already forked from a previous session.
     */
    forkSession: () => Promise<string>;
    /**
     * Creates an embedded wallet for the current user.
     *
     * This method will error if the user already has an embedded wallet or if they
     * exit in the middle of the flow.
     *
     * If the `config.embeddedWallets.requireUserOwnedRecoveryOnCreate` property is set to true,
     * this will prompt the user to complete a recovery flow to secure the recovery
     * share of their embedded wallet.
     *
     * Otherwise (the default), Privy will secure the recovery share, and the embedded wallet
     * will be created without showing any UIs to the user.
     *
     * @returns Promise for the {@link Wallet} object for the newly created embedded wallet
     */
    createWallet: () => Promise<Wallet>;
    /**
     * This method will error if the user does not have an embedded wallet, if the user's
     * embedded wallet already has a password set, or if the user exits in the middle of the flow.
     *
     * @returns Promise for the {@link Wallet} object for the updated embedded wallet
     */
    setWalletPassword: () => Promise<Wallet>;
    /**
     * Prompts a user to sign a message using their embedded wallet using EIP-191's `personal_sign`
     * method (0x45).
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     *
     * If the `config.embeddedWallets.noPromptOnSignature` property is set to true, the signature will
     * be computed without prompting the user. Otherwise (the default), Privy will show the user a modal
     * to prompt them for a signature. This can be customized via the {@link SignMessageModalUIOptions}.
     *
     * @param message {string} message to be signed
     * @param uiOptions {@link SignMessageModalUIOptions} (optional) UI options to customize the signature prompt modal
     * @returns Promise for the signature as a string
     */
    signMessage: (message: string, uiOptions?: SignMessageModalUIOptions) => Promise<string>;
    /**
     * Prompts a user to sign a message using their embedded wallet using EIP-712's `eth_signTypedData_v4`.
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     *
     * @param message {SignTypedDataParams} typed data payload to be signed
     * @param uiOptions {@link SignMessageModalUIOptions} (optional) UI options to customize the signature prompt modal
     * @returns Promise for the signature as a string
     */
    signTypedData: (typedData: SignTypedDataParams, uiOptions?: SignMessageModalUIOptions) => Promise<string>;
    /**
     * Function to control the visibility of the enrollment modal.
     *
     * @param show {boolean} controls the visibility of the enrollment modal.
     * @returns Promise for opening the enrollment modal.
     */
    enrollInMfa: (show?: boolean) => void;
    /**
     * Initiate the enrollment flow for MFA for the current user.
     *
     * @param mfaMethod {@link MfaMethod} The MFA method to enroll for the current user.
     * @param meta {@link {phoneNumber: string}} The meta data needed to complete the MFA flow.
     * @returns Promise for enrolling the current user with the chosen MFA method.
     */
    initEnrollmentWithSms: (meta: {
        phoneNumber: string;
    }) => Promise<void>;
    /**
     * Initiate the enrollment flow for TOTP MFA for the current user.
     *
     * @returns {@link {secret: string; authUrl: string}} The TOTP Auth Url is used to encode
     * into a QR Code for the user to scane.
     */
    initEnrollmentWithTotp: () => Promise<{
        secret: string;
        authUrl: string;
    }>;
    /**
     * Initiate the enrollment flow for Passkey MFA for the current user.
     *
     * @returns {@link void} The TOTP Auth Url is used to encode
     * into a QR Code for the user to scane.
     */
    initEnrollmentWithPasskey: () => Promise<void>;
    /**
     * Submit the MFA code to complete SMS enrollment process.
     *
     * @param meta {@link {phoneNumber: string; mfaCode: string}} The MFA code and phone number to submit.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithSms: (meta: {
        phoneNumber: string;
        mfaCode: string;
    }) => Promise<void>;
    /**
     * Submit the MFA code to complete TOTP enrollment process.
     *
     * @param meta {@link {mfaCode: string}} The MFA code.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithTotp: (meta: {
        mfaCode: string;
    }) => Promise<void>;
    /**
     * Submit the passkey to complete the enrollment process.
     *
     * @param meta {@link {credentialIds: string[]}} The passkey credentialIds to enroll in MFA.
     * @returns Promise for the MFA code submission.
     */
    submitEnrollmentWithPasskey: (meta: {
        credentialIds: string[];
    }) => Promise<void>;
    /**
     * Triggers the MFA verification flow if the user has an MFA method enrolled.
     *
     * @returns Promise for triggering the MFA verification flow.
     */
    promptMfa: () => Promise<void>;
    /**
     * Initiate the MFA flow for the current user.
     *
     * @param mfaMethod {@link MfaMethod} The available MFA method to trigger for the current user.
     * @returns Promise for sending the MFA code to the user's device.
     */
    init: (mfaMethod: MfaMethod) => Promise<void | PublicKeyCredentialRequestOptionsJSON>;
    /**
     * Submit the MFA code for the current user. This will attempt to complete the MFA flow.
     *
     * This will reject if:
     *   - The verification attempt failed
     *   - The max number of verification attempts has been reached
     *   - The MFA attempt timed out
     *
     * These errors can be caught and handled accordingly using the error helpers `errorIndicatesMfaVerificationFailed`,
     * `errorIndicatesMaxMfaRetries`, `errorIndicatesMfaTimeout` exported from 'react-auth'.
     *
     * @param method {@link MfaMethod} The MFA method to be used.
     * @param mfaCode {string} The MFA code to submit.
     * @returns Promise for the MFA code submission.
     */
    submit: (mfaMethod: MfaMethod, mfaCode: string | PublicKeyCredentialRequestOptionsJSON) => Promise<void>;
    /**
     * Cancel the MFA flow for the current user. If there is no pending MFA verification,
     * this function is a no-op.
     *
     * Call this method instead of `submit` when a user has been prompted for
     * MFA but decides to exit the flow.
     *
     * @returns void.
     */
    cancel: () => void;
    /**
     * Remove the MFA method for the current user.
     *
     * @param method {@link MfaMethod} The MFA method to remove for the current user.
     * @returns Promise for removing the MFA method for the current user.
     */
    unenroll: (method: MfaMethod) => Promise<void>;
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     *
     * If no `chainId` is specified as part of the {@link UnsignedTransactionRequest}, Privy will default
     * to the embedded wallet's current chain ID.
     *
     * If the `config.embeddedWallets.noPromptOnSignature` property is set to true, the wallet will
     * attempt to send the transaction without prompting the user. Otherwise (the default), Privy
     * will show the user a modal to have them confirm the transaction. This can be customized via
     * the {@link SendTransactionModalUIOptions}.
     *
     * @param data {@link UnsignedTransactionRequest} transaction to be sent
     * @param uiOptions {@link SendTransactionModalUIOptions} (optional) UI options to customize the transaction request modal
     * @param fundWalletConfig {@link FundWalletConfig} (optional) Configuration surrounding funding the wallet (if enabled), in the case of insufficient funds
     * @returns Promise for the transaction's {@link TransactionReceipt}
     */
    sendTransaction: (data: UnsignedTransactionRequest, uiOptions?: SendTransactionModalUIOptions, fundWalletConfig?: FundWalletConfig) => Promise<TransactionReceipt>;
    /**
     * Shows the user a Privy modal, from which they can copy their embedded wallet's private
     * key for easy export to another wallet client (e.g. MetaMask). The private key is loaded
     * on an iframe running on a separate domain from your app, meaning your app cannot access it.
     *
     * This method will error if the user is not authenticated or does not have an embedded wallet.
     * @returns Promise that resolves once the user exits the modal
     */
    exportWallet: () => Promise<void>;
    /**
     * Check whether the Privy Modal is visible.
     */
    isModalOpen: boolean;
}
/**
 * [React Hook](https://reactjs.org/docs/hooks-intro.html) that allows you to manage the user's current authentication state and access their linked accounts.
 *
 * You should use this hook to access the Privy SDK from within your React components and custom hooks.
 */
declare const usePrivy: () => PrivyInterface;

/**
 * Allows you to manage the user's currently connected wallets.
 * You can access the fields and methods documented here via the {@link useWallets} hook.
 */
interface UseWalletsInterface {
    /**
     * The user's connected wallets.
     */
    wallets: ConnectedWallet[];
    ready: boolean;
}
declare function useWallets(): UseWalletsInterface;

/**
 * Use this hook to execute the MFA flow with Privy.
 *
 * @returns promptMfa - prompts the user to complete MFA verification
 * @returns init - starts the MFA verification flow
 * @returns submit - completes the MFA verification flow
 * @returns cancel - cancels the MFA verification flow
 *
 * @example
 * // MFA flow
 *
 * const MFAModal = ({ mfaMethods, isOpen, setIsOpen }: Props) => {
 *   const {init, submit, cancel} = useMfa();
 *   const [selectedMethod, setSelectedMethod] = useState(null)
 *   const [mfaCode, setMfaCode] = useState('')
 *
 *   const handleClose = () => {
 *     cancel();
 *     setIsOpen(false);
 *   };
 *
 *   return (
 *     <Modal isOpen={isOpen} onClose={handleClose}>
 *       // Capture the user's MFA code
 *       {selectedMethod && (
 *         <button
 *           onClick={async () => {
 *             await submit(selectedMethod, mfsCode)
 *             setSelectedMethod(null)
 *             setIsOpen(false)
 *           }}
 *         />
 *       )}
 *       {mfaMethods.map(method => (
 *         <button
 *           onClick={async () => {
 *             await init(method);
 *             setSelectedMethod(method)
 *           }}
 *         >
 *           Choose {method} for MFA
 *         </button>
 *       ))}
 *     </Modal>
 *   )
 * };
 *
 * @example
 * // Error handling
 *
 * import {
 *   errorIndicatesMfaVerificationFailed,
 *   errorIndicatesMfaTimeout,
 *   errorIndicatesMfaMaxAttempts
 * } from '@privy-io/react-auth';
 * const {submit} = useMfa();
 * const [errorState, setErrorState] = useState<string | null>(null);
 *
 * <button
 *   onClick={async () => {
 *     try {
 *       submit('sms', '<user-mfa-code>');
 *     }
 *     catch (e) {
 *       if (errorIndicatesMfaVerificationFailed(e)) {
 *         setErrorState('Verification failed, resubmit.')
 *       }
 *       else if (errorIndicatesMfaMaxAttempts(e)) {
 *         setErrorState('Max attempts reached, re-initialize MFA.')
 *       }
 *       else if (errorIndicatesMfaTimeout(e)) {
 *         setErrorState('Timeout reached, re-initialize MFA.')
 *       }
 *   }}
 * >
 *   {errorState ?? 'Verify SMS MFA Code'}
 * </button>
 *
 */
declare function useMfa(): {
    promptMfa: () => Promise<void>;
    init: (mfaMethod: "sms" | "totp" | "passkey") => Promise<void | _simplewebauthn_types.PublicKeyCredentialRequestOptionsJSON>;
    submit: (mfaMethod: "sms" | "totp" | "passkey", mfaCode: string | _simplewebauthn_types.PublicKeyCredentialRequestOptionsJSON) => Promise<void>;
    cancel: () => void;
};

/**
 * Use this hook to enroll a user in MFA
 *
 * @returns initEnrollmentWithSms - starts the MFA enrollment flow for SMS
 * @returns initEnrollmentWithTotp - starts the MFA enrollment flow for TOTP
 * @returns submitEnrollmentWithSms - completes the MFA enrollment flow for SMS
 * @returns submitEnrollmentWithTotp - completes the MFA enrollment flow for TOTP
 * @returns unenrollWithSms - unenrolls the SMS MFA method
 * @returns unenrollWithTotp - unenrolls the TOTP MFA method
 * @returns showMfaEnrollmentModal - opens the MFA enrollment modal
 * @returns closeMfaEnrollmentModal - closes the MFA enrollment modal
 *
 * @example
 * const {unenrollWithSms} = useMfaEnrollment();
 *
 * <button
 *  onClick={() => {
 *    unenrollWithSms();
 *  }}
 * >
 * Unenroll in SMS MFA
 * </button>
 *
 * @example
 * const {unenrollWithTotp} = useMfaEnrollment();
 *
 * <button
 *  onClick={() => {
 *    unenrollWithTotp();
 *  }}
 * >
 *  Unenroll in TOTP MFA
 * </button>
 */
declare function useMfaEnrollment(): {
    initEnrollmentWithSms: (meta: {
        phoneNumber: string;
    }) => Promise<void>;
    initEnrollmentWithTotp: () => Promise<{
        secret: string;
        authUrl: string;
    }>;
    initEnrollmentWithPasskey: () => Promise<void>;
    submitEnrollmentWithSms: (meta: {
        phoneNumber: string;
        mfaCode: string;
    }) => Promise<void>;
    submitEnrollmentWithTotp: (meta: {
        mfaCode: string;
    }) => Promise<void>;
    submitEnrollmentWithPasskey: (meta: {
        credentialIds: string[];
    }) => Promise<void>;
    unenrollWithSms: () => Promise<void>;
    unenrollWithTotp: () => Promise<void>;
    unenrollWithPasskey: () => Promise<void>;
    showMfaEnrollmentModal: () => void;
    closeMfaEnrollmentModal: () => void;
};

declare class PrivyIframeError extends Error {
    type: PrivyIframeErrorTypesType;
    constructor(type: PrivyIframeErrorTypesType, message: string);
}
declare function errorIndicatesMfaTimeout(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMfaVerificationFailed(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMaxMfaRetries(error: unknown): error is PrivyIframeError;

declare const VERSION: string;

type CallbackError = (error: PrivyErrorCode) => void;
interface PrivyEvents {
    login: {
        /**
         * Callback that will execute once a `login` flow successfully completes.
         * - If `config.embeddedWallets.createOnLogin` is set to 'off' or a wallet creation flow is not applicable,
         *   this will run after the user successfully authenticates.
         * - If `config.embeddedWallets.createOnLogin` is set to 'users-without-wallets' or 'all-users',
         *   this will run after the user successfully authenticates _and_ creates their wallet (if applicable).
         * - If a user is already authenticated, this will run immediately and the `wasAlreadyAuthenticated` flag will be set to `true`.
         *
         * @param user {@link User} the `user` oject corresponding to the authenticated user
         * @param isNewUser {boolean} boolean flag indicating if this is the user's first time logging in to your app
         * @param wasAlreadyAuthenticated {boolean} - boolean flag indicating whether the user entered the application already authenticated
         * @param loginMethod {string} - the method used by the user to login
         * @param loginAccount - the account corresponding to the loginMethod used
         */
        onComplete?: (user: User, isNewUser: boolean, wasAlreadyAuthenticated: boolean, loginMethod: LoginMethod | null, loginAccount: LinkedAccountWithMetadata | null) => void;
        /**
         * @experimental
         *
         * Callback that will execute once a successful OAuth login flow completes.
         * This will only run in the case of an OAuth login flow.
         *
         * This will always be called before `onComplete` in the case of an OAuth login flow.
         * If you will be doing anything after the user is logged in (e.g. sending data to your API or redirecting to an authenticated route), you should wait for `onComplete` to run.
         *
         * @param oAuthProviderTokens {@link OAuthProviderTokens} - the OAuth tokens returned from the OAuth provider
         */
        onOAuthLoginComplete?: (oAuthProviderTokens: OAuthProviderTokens) => void;
        /**
         * Callback that will execute in the case of a non-successful login.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *
         */
        onError?: CallbackError;
    };
    logout: {
        /**
         * Callback that will execute when a user successfully logs out.
         */
        onSuccess?: () => void;
    };
    connectWallet: {
        /**
         * Callback that will execute once a successful `connectWallet` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         *
         * @param wallet {@link BaseConnectedWallet} the `wallet` object correspending to the connection
         */
        onSuccess?: (wallet: BaseConnectedWallet) => void;
        /**
         * Callback that will execute in the case of a non-successful wallet connection.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         */
        onError?: CallbackError;
    };
    createWallet: {
        /**
         * Callback that will execute once on a successful embedded wallet creation.
         * This will run when `createWallet` is called manually, or when `config.embeddedWallets.createOnLogin` triggers
         * an automatic wallet creation.
         *
         * @param wallet {@link BaseConnectedWallet}- the created `wallet` object
         *
         */
        onSuccess?: (wallet: Wallet) => void;
        /**
         * Callback that will execute in the case of a non-successful wallet creation.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *
         */
        onError?: CallbackError;
    };
    linkAccount: {
        /**
         * Callback that will execute once on a successful linking of a new account/login method.
         * This will run when any of the 'link' methods are called manually.
         * @param user {@link User}- the user the account was linked to
         * @param linkMethod {@link LoginMethod}- the type of linked account
         * @param linkedAccount - the newly linked account
         */
        onSuccess?: (user: User, linkMethod: LoginMethod, linkedAccount: LinkedAccountWithMetadata) => void;
        /**
         * Callback that will execute in the case of a non-successful account linking.
         *
         * @param error {PrivyErrorCode} - the corresponding error code
         *
         */
        onError?: CallbackError;
    };
    configureMfa: {
        /**
         * Callback that will execute when MFA is required to complete a given action.
         * @param mfaMethods {@link MfaMethod[]} - List of MFA methods that the user can choose from
         */
        onMfaRequired: (mfaMethods: MfaMethod[]) => void;
    };
    setWalletPassword: {
        /**
         * Callback that will execute once a successful `setWalletPassword` completes.
         * @param  wallet {@link Wallet}- the `wallet` object that the password was set for
         */
        onSuccess?: (wallet: Wallet) => void;
        /**
         * Callback that will execute in the case of a non-successful setWalletPassword.
         *
         * @param error {PrivyErrorCode} - the corresponding error code
         */
        onError?: CallbackError;
    };
    signMessage: {
        /**
         * Callback that will execute once a successful `signMessage` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         * @param signature - the signature (type string) of the embedded wallet used to sign message
         */
        onSuccess?: (signature: string) => void;
        /**
         * Callback that will execute in the case of a non-successful signMessage.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    signTypedData: {
        /**
         * Callback that will execute once a successful `signTypedData` completes.
         * @param signature - the signature (type string) of the embedded wallet used to sign
         */
        onSuccess?: (signature: string) => void;
        /**
         * Callback that will execute in the case of a non-successful signTypedData.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    sendTransaction: {
        /**
         * Callback that will execute once a successful `sendTransaction` completes.
         * This will not run in the case of a wallet-based authentication or link flow.
         * @param response - the response (type TransactionResponse https://docs.ethers.org/v5/api/providers/types/#providers-TransactionResponse) from the successful transaction
         */
        onSuccess?: (response: TransactionResponse) => void;
        /**
         * Callback that will execute in the case of a non-successful sendTransaction.
         *
         * @param error {@link PrivyErrorCode} - the corresponding error code
         *  */
        onError?: CallbackError;
    };
    accessToken: {
        /**
         * Callback that will execute when a user's access token is granted.
         * @param accessToken - The user's access token
         */
        onAccessTokenGranted: (accessToken: string) => void;
        /**
         * Callback that will execute when a user's access token is removed.
         */
        onAccessTokenRemoved: () => void;
    };
}

/**
 * Use this hook to log the user in, and to attach callbacks
 * for successful `login`s, already-`authenticated` users, and
 * `login` errors.
 *
 * @param callbacks.onComplete {@link PrivyEvents} callback to execute for already- or newly-`authenticated` users
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `login`.
 * @returns login - opens the Privy modal and prompts the user to login
 */
declare function useLogin(callbacks?: PrivyEvents['login']): {
    /**
     * Opens the Privy login modal and prompts the user to login.
     */
    login: () => void;
};

/**
 * Use this hook to log the user out, and to attach a callback after a successful logout.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully logs out.
 * @returns logout - logs the user out and clears their authentication state.
 */
declare function useLogout(callbacks?: PrivyEvents['logout']): {
    /**
     * Log the current user out and clears their authentication state. `authenticated` will become false, `user` will become null, and the Privy Auth tokens will be deleted from the browser's local storage.
     */
    logout: () => Promise<void>;
};

type UseLoginWithOAuth = {
    /**
     * Redirect to a login page for the given OAuth provider without using Privy's UI
     *
     * @returns a Promise that resolves when the redirect _(using `window.assign`)_ is complete, or rejects if there was an error.
     *
     * @example
     * const {initOAuth} = useLoginWithOAuth()
     *
     * <Button onPress={() => initOAuth({ provider: 'google' })} /> *
     */
    initOAuth: ({ provider }: {
        provider: OAuthProviderType;
    }) => Promise<void>;
    /**
     * Used to log users in via various OAuth providers without using Privy's UI
     *
     * @returns a Promise that resolves with the User if login was successful or rejects if there was an error.
     *
     * @example
     * const {loginWithOAuth} = useLoginWithOAuth()
     *
     * <Button onPress={loginWithOAuth} /> *
     */
    loginWithOAuth: () => Promise<User | undefined>;
    /**
     * Indicates a headless OAuth flow is in progress
     */
    loading: boolean;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with an OAuth provider, without using any Privy UIs.
 */
declare function useLoginWithOAuth(): UseLoginWithOAuth;

type SendCodeToEmail = {
    email: string;
};
type UseLoginWithEmail = {
    /**
     * Sends a one-time-passcode (OTP) to the user's email address.
     *
     * @param opts {@link SendCodeToEmail} options for sending the OTP
     * @param opts.email {string} the user's email address
     *
     * @returns a Promise that resolves if the OTP was successfully sent to the email,
     * or rejects if there was an error.
     */
    sendCode: ({ email }: SendCodeToEmail) => Promise<void>;
    /**
     * Log a user in with a one-time-passcode (OTP) that has been sent to their
     * email address via {@link sendCode}
     *
     * For a single OTP, you may call this method up to a maximum of 5 times, to handle
     * errors where the user incorrectly enters the OTP in your UIs.
     *
     * After 5 attempts of {@link loginWithCode}, the existing OTP is no longer valid, and you
     * must request a new one for the user via {@link sendCode}
     *
     * @param opts {@link LoginWithCode} options for logging the user in with an OTP
     * @param opts.code {string} the OTP provided by the user
     *
     * @returns a Promise that resolves if the inputted OTP was valid, or rejects if there was an error.
     */
    loginWithCode: ({ code }: LoginWithCode) => Promise<void>;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with email, without using any Privy UIs.
 *
 * @returns sendCode - {@link sendCode} sends a one-time-code to the user's email address.
 * @returns loginWithCode - {@link loginWithCode} - logs a user in with a one-time-code, maximum 5 attempts.
 */
declare const useLoginWithEmail: () => UseLoginWithEmail;

type SendCodeToSms = {
    phoneNumber: string;
};
type UseLoginWithSms = {
    /**
     * Sends a one-time-passcode (OTP) to the user's phone number.
     *
     * @param opts {@link SendCodeToSms} options for sending the OTP
     * @param opts.phoneNumber {string} the user's phone number
     *
     * The phone number will ignore all non numerical values in the string except for the optional '+' first character for country code specification.
     * By default, the implicit phone number country code is +1/US. So any phone number inputted is default read as a US phone number.
     * Explicitly prepending a (+)1 to the phone number will do nothing, and the phone number will still be read and parsed as a US phone number.
     * If you are trying to send sms to a non (+1) phone number, you must append a +${countryCode} to the beginning of the input value.
     *
     * @returns a Promise that resolves if the OTP was successfully sent to the email,
     * or rejects if there was an error.
     */
    sendCode: ({ phoneNumber }: SendCodeToSms) => Promise<void>;
    /**
     * Log a user in with a one-time-passcode (OTP) that has been sent to their
     * phone number via {@link sendCode}
     *
     * For a single OTP, you may call this method up to a maximum of 5 times, to handle
     * errors where the user incorrectly enters the OTP in your UIs.
     *
     * After 5 attempts of {@link loginWithCode}, the existing OTP is no longer valid, and you
     * must request a new one for the user via {@link sendCode}
     *
     * @param opts {@link LoginWithCode} options for logging the user in with an OTP
     * @param opts.code {string} the OTP provided by the user
     *
     * @returns a Promise that resolves if the inputted OTP was valid, or rejects if there was an error.
     */
    loginWithCode: ({ code }: LoginWithCode) => Promise<void>;
    /**
     * The current state of the login with SMS flow.
     */
    state: OtpFlowState;
};
/**
 * @experimental
 *
 * Use this hook to log the user in with sms, without using any Privy UIs.
 *
 * @returns sendCode - {@link sendCode} sends a one-time-code to the user's phone number.
 * @returns loginWithCode - {@link loginWithCode} - logs a user in with a one-time-code, maximum 5 attempts.
 */
declare const useLoginWithSms: () => UseLoginWithSms;

/**
 * Use this hook to register your app's logic for prompting users to complete MFA.
 * When a user is required to complete MFA in order to use their embedded wallet,
 * Privy will invoke the logic you register here to have the user complete MFA.
 * This hook should be mounted somewhere towards the root of your application tree
 * so that it can handle MFA required events from the entire application.
 *
 * @param callbacks {@link PrivyEvents} callbacks to register your logic for
 * prompting users to complete MFA.
 * @param callbacks.onMfaRequired {@link PrivyEvents} Privy will invoke this callback
 * whenever the user is required to complete MFA. Pass in a function that will prompt
 * your user to complete MFA with Privy (using `useMfa`) and only returns once
 * MFA has been completed.
 * @param callbacks.onError {@link PrivyEvents} Privy will invoke this callback whenever
 * there is an error in the MFA flow. Use this callback to define logic around how
 * you'd like to handle these errors (e.g. showing a UI to the user).
 *
 * @example
 * const [mfaMethods, setMfaMethods] = useState([])
 * const [isMfaDialogOpen, setIsMfaDialogOpen] = useState(false)
 *
 * // Prompt user to select from their enabled MFA methods
 * useRegisterMfaListener({
 *   onMfaRequired: async (methods) => {
 *     setMfaMethods(methods)
 *     setIsMfaDialogOpen(true);
 *   },
 * });
 *
 * // Within MFA modal allow the user to select an MFA method
 * <MFAModal
 *   mfaMethods={mfaMethods}
 *   isOpen={isMfaDialogOpen}
 *   setIsOpen={setIsMfaDialogOpen}
 * />
 *
 * See `useMfa` for how to execute the MFA flow within Privy in your App.
 */
declare function useRegisterMfaListener(callbacks: PrivyEvents['configureMfa']): void;

/**
 * Use this hook to link a new account to an authenticated user, and to attach
 * callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute after a successful account linkage
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `link`.
 *
 * @returns linkEmail - opens the Privy modal and prompts the user to link an email address
 * @returns linkPhone - opens the Privy modal and prompts the user to link a phone number
 * @returns linkWallet - opens the Privy modal and prompts the user to link an external wallet
 * @returns linkGoogle - opens the Privy modal and prompts the user to link their Google account
 * @returns linkApple - opens the Privy modal and prompts the user to link their Apple account
 * @returns linkTwitter - opens the Privy modal and prompts the user to link their Twitter account
 * @returns linkDiscord - opens the Privy modal and prompts the user to link their Discord account
 * @returns linkGithub - opens the Privy modal and prompts the user to link their Github account
 * @returns linkLinkedIn - opens the Privy modal and prompts the user to link their LinkedIn account
 * @returns linkTikTok - opens the Privy modal and prompts the user to link their TikTok account
 * @returns linkSpotify - opens the Privy modal and prompts the user to link their Spotify account
 * @returns linkInstagram - opens the Privy modal and prompts the user to link their Instagram account
 * @returns linkFarcaster - opens the Privy modal and prompts the user to link their Farcaster account
 */
declare function useLinkAccount(callbacks?: PrivyEvents['linkAccount']): {
    linkEmail: () => void;
    linkPhone: () => void;
    linkWallet: () => void;
    linkGoogle: () => void;
    linkApple: () => void;
    linkTwitter: () => void;
    linkDiscord: () => void;
    linkGithub: () => void;
    linkLinkedIn: () => void;
    linkTiktok: () => void;
    linkSpotify: () => void;
    linkInstagram: () => void;
    linkFarcaster: () => void;
};

/**
 * Use this hook to connect the user's external wallet, and to attach
 * callbacks after a user succesfully connects their wallet, or if there
 * is an error during the connection attempt.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully connects their wallet
 * @param callbacks.onError {@link PrivyEvents} callback to execute when a user attempts to connect their wallet, but there is an error
 * @returns connectWallet - opens the Privy modal and prompts the user to connect an external wallet
 */
declare function useConnectWallet(callbacks?: PrivyEvents['connectWallet']): {
    /**
     * Opens the Privy modal and prompts the user to connect a wallet.
     */
    connectWallet: () => void;
};

/**
 * Use this hook to create a privy wallet for a user, and to attach a callback after successful wallet creation.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute when a user successfully creates a privy wallet
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `cresteWallet`.
 * @returns createWallet - creates a privy wallet for the user.
 */
declare function useCreateWallet(callbacks?: PrivyEvents['createWallet']): {
    /**
     * Creates an embedded wallet for the current user.
     *
     * This method will error if the user already has an embedded wallet
     *
     * If the `config.embeddedWallets.requireUserOwnedRecoveryOnCreate` property is set to true,
     * this will prompt the user to complete a recovery flow to secure
     * the recovery share of their embedded wallet.
     *
     * Otherwise (the default), Privy will secure the recovery share, and the embedded wallet
     * will be created without showing any UIs to the user.
     *
     * @returns Promise for the {@link Wallet} object for the newly created embedded wallet
     */
    createWallet: () => Promise<Wallet>;
};

/**
 * Method to fund a user's wallet via Privy's fiat on-ramp integration by inputting a valid wallet address.
 * You can access the fields and methods documented here via the {@link useFundWallet} hook.
 */
interface UseFundWalletInterface {
    /**
     * Prompt the user to go through the fiat onramp flow and fund the specified wallet.
     *
     * This will open the modal with a prompt for the user to navigate to a third-party on-ramp provider.
     *
     * Once the user continues to the on-ramp flow, Privy will display the on-ramp status screen, and wait
     * for the transaction to complete.
     *
     * Note: Even after a successful funding, funds can take a few minutes to arrive in the user's wallet.
     *
     * The current supported provider is Moonpay.
     *
     * @param address typed data payload to be signed
     * @param fundWalletConfig {@link FundWalletConfig} (optional) options to customize the wallet fund modal
     */
    fundWallet: (address: string, fundWalletConfig?: FundWalletConfig) => Promise<void>;
}
/**
 * Hook to fund a wallet via Privy's fiat on-ramp integration given the wallet address.
 * @returns fundWallet - function to on-ramp funds to any given wallet
 */
declare const useFundWallet: () => UseFundWalletInterface;

/**
 * Use this hook to send a transaction using the embedded wallet and to attach callbacks for success and errors.
 * Transactions sent from the embedded wallet using transaction functions from non-Privy libraries
 * will not trigger the callbacks.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful transaction sent
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `sendTransaction`
 * @returns sendTransaction - prompts the user send a transaction using their embedded wallet
 */
declare function useSendTransaction(callbacks?: PrivyEvents['sendTransaction']): {
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     */
    sendTransaction: (data: UnsignedTransactionRequest, uiOptions?: SendTransactionModalUIOptions | undefined, fundWalletConfig?: FundWalletConfig | undefined) => Promise<TransactionReceipt>;
};

/**
 * Use this hook to set a password on the embedded wallet, and to attach callbacks
 * for successful `password set`s, and `password set` errors.
 * Note that the callbacks will only fire for explicit `setWalletPassword` calls from the Privy SDK.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful password setting
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `setWalletPassword` -- ie.
 * the user doesn't have an embedded wallet, the user already has a set password on the wallet, or the password flow is prematurely exited.
 * @returns setWalletPassword - opens the Privy modal and prompts the user to set a password on the embedded wallet
 */
declare function useSetWalletPassword(callbacks?: PrivyEvents['setWalletPassword']): {
    /**
     * Opens the Privy set password modal and prompts the user to set wallet password.
     */
    setWalletPassword: () => Promise<Wallet>;
};

/**
 * Use this hook to sign a message using the embedded wallet, and to attach callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful message signature
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `signMessage`
 * @returns signMessage - prompts the user to sign a message with their embedded wallet
 */
declare function useSignMessage(callbacks?: PrivyEvents['signMessage']): {
    /**
     * Prompts a user to sign a message using their embedded wallet.
     */
    signMessage: (message: string, uiOptions?: SignMessageModalUIOptions | undefined) => Promise<string>;
};

/**
 * Use this hook to sign typed data using the embedded wallet, and to attach callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful signature
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `signTypedData`
 * @returns signTypedData - prompts the user to sign typed data with their embedded wallet
 */
declare function useSignTypedData(callbacks?: PrivyEvents['signTypedData']): {
    /**
     * Prompts a user to sign typed data using their embedded wallet.
     */
    signTypedData: (typedData: SignTypedDataParams, uiOptions?: SignMessageModalUIOptions | undefined) => Promise<string>;
};

/**
 * Use this hook to check whether or not the Privy modal is currently visible.
 *
 * @returns isOpen - whether or not the Privy modal is visible
 */
declare const useModalStatus: () => {
    isOpen: boolean;
};

/**
 * Use this hook to tap into access token grant and revoke events.
 *
 * @param callbacks.onAccessTokenGranted {@link PrivyEvents} callback to automatically execute when a user is granted an access token. This will be called when a user logs in, or when a user's access token is refreshed.
 * @param callbacks.onAccessTokenRemoved {@link PrivyEvents} callback to automatically execute when a user's access token is revoked.
 * @returns getAccessToken - returns the user's current access token
 */
declare function useToken(callbacks?: PrivyEvents['accessToken']): {
    getAccessToken: () => Promise<string | null>;
};

/**
 * Use this hook to write to Farcaster. This is an experimental feature.
 *
 * @experimental
 */
declare function useExperimentalFarcasterSigner(): {
    getFarcasterSignerPublicKey: () => Promise<Uint8Array>;
    signFarcasterMessage: (messageHash: Uint8Array) => Promise<Uint8Array>;
    requestFarcasterSignerFromWarpcast: () => Promise<void>;
};

/**
 * Allows you to override the RPC url for the given chain
 *
 * @param chain {@link Chain} chain you want to modify
 * @param rpcUrl {@type string} rpc url you want to use for this chain
 * @returns modified chain object
 *
 * @example
 *
 * ```ts
 * import { mainnet } from 'viem/chains';
 * import { addRpcUrlOverrideToChain } from '@privy-io/react-auth';
 *
 * const mainnetOverride = addRpcUrlOverrideToChain(mainnet, INSERT_MAINNET_OVERRIDE_URL);
 * ```
 */
declare function addRpcUrlOverrideToChain(chain: Chain, rpcUrl: string): {
    rpcUrls: {
        privyWalletOverride: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
    } | {
        privyWalletOverride: {
            http: string[];
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
    };
    id: number;
    name: string;
    network?: string | undefined;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    blockExplorers?: {
        [key: string]: {
            name: string;
            url: string;
        };
        default: {
            name: string;
            url: string;
        };
    } | undefined;
    testnet?: boolean | undefined;
};

export { Apple, AppleOAuthWithMetadata, AsExternalProvider, CallbackError, Captcha, ConnectedWallet, ConnectorManager, ContractUIOptions, Discord, DiscordOAuthWithMetadata, EIP1193Provider, Email, EmailWithMetadata, Farcaster, FarcasterWithMetadata, FundWalletConfig, Github, GithubOAuthWithMetadata, Google, GoogleOAuthWithMetadata, LinkedIn, LinkedInOAuthWithMetadata, LoginMethodOrderOption, LoginWithCode, MessageTypes, MfaMethod, MoonpayConfig, MoonpayCurrencyCode, MoonpayPaymentMethod, NonEmptyArray, OAuthProviderTokens, OAuthProviderType, Passkey, PasskeyWithMetadata, Phone, PhoneWithMetadata, PriceDisplayOptions, PrivyClient, PrivyClientConfig, PrivyEvents, PrivyInterface, PrivyProvider, PrivyProviderProps, PrivyProxyProvider, Quantity, DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS, SendCodeToEmail, SendCodeToSms, SendTransactionModalUIOptions, SignMessageModalUIOptions, SignTypedDataParams, Tiktok, TiktokOAuthWithMetadata, TransactionLog, TransactionReceipt, TransactionUIOptions, Twitter, TwitterOAuthWithMetadata, TypedMessage, UnsignedTransactionRequest, UseFundWalletInterface, UseLoginWithEmail, UseLoginWithSms, UseWalletsInterface, User, VERSION, Wallet, WalletConnector, WalletListEntry, WalletWithMetadata, addRpcUrlOverrideToChain, errorIndicatesMaxMfaRetries, errorIndicatesMfaTimeout, errorIndicatesMfaVerificationFailed, getAccessToken, useConnectWallet, useCreateWallet, useExperimentalFarcasterSigner, useFundWallet, useLinkAccount, useLogin, useLoginWithEmail, useLoginWithOAuth, useLoginWithSms, useLogout, useMfa, useMfaEnrollment, useModalStatus, usePrivy, useRegisterMfaListener, useSendTransaction, useSetWalletPassword, useSignMessage, useSignTypedData, useToken, useWallets };
